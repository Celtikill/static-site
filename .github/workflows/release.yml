name: RELEASE - Version Management and Deployment

on:
  # Trigger on version tags - maintains existing strategy
  push:
    tags:
      - 'v*.*.*'           # Production releases (v1.0.0) â†’ prod
      - 'v*.*.*-rc*'       # Release candidates (v1.0.0-rc1) â†’ staging  
      - 'v*.*.*-hotfix.*'  # Hotfixes (v1.0.1-hotfix.1) â†’ staging
  
  # Manual release creation
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to create'
        required: true
        type: choice
        options: [patch, minor, major, rc, hotfix]
      custom_version:
        description: 'Custom version (optional)'
        required: false
        type: string
      deploy_after_tag:
        description: 'Trigger deployment after creating tag'
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  id-token: write

jobs:
  release:
    name: Create Release and Trigger Deployment
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.version.outputs.environment }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine Version and Environment
        id: version
        run: |
          echo "# ðŸ“¦ RELEASE Management" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # If triggered by tag push
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
            echo "ðŸ“Œ Using existing tag: $VERSION" >> $GITHUB_STEP_SUMMARY
          
          # If manual with custom version
          elif [[ -n "${{ github.event.inputs.custom_version }}" ]]; then
            VERSION="${{ github.event.inputs.custom_version }}"
            if [[ ! "$VERSION" =~ ^v ]]; then
              VERSION="v$VERSION"
            fi
            echo "ðŸ“ Using custom version: $VERSION" >> $GITHUB_STEP_SUMMARY
          
          # If manual with version type
          else
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "ðŸ“Š Latest tag: $LATEST_TAG" >> $GITHUB_STEP_SUMMARY
            
            # Parse version components
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT_VERSION%%-*}"
            
            # Calculate new version
            case "${{ github.event.inputs.version_type }}" in
              major)
                VERSION="v$((MAJOR + 1)).0.0"
                ;;
              minor)
                VERSION="v${MAJOR}.$((MINOR + 1)).0"
                ;;
              patch)
                VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
              rc)
                RC_COUNT=$(git tag -l "v${MAJOR}.$((MINOR + 1)).0-rc*" | wc -l)
                VERSION="v${MAJOR}.$((MINOR + 1)).0-rc$((RC_COUNT + 1))"
                ;;
              hotfix)
                HOTFIX_COUNT=$(git tag -l "v${MAJOR}.${MINOR}.$((PATCH + 1))-hotfix.*" | wc -l)
                VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))-hotfix.$((HOTFIX_COUNT + 1))"
                ;;
            esac
            echo "ðŸ”¢ Calculated version: $VERSION" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Determine target environment based on version pattern
          if [[ "$VERSION" =~ -rc ]]; then
            ENVIRONMENT="staging"
            IS_PRERELEASE="true"
            echo "ðŸŽ¯ Target: staging (release candidate)" >> $GITHUB_STEP_SUMMARY
          elif [[ "$VERSION" =~ -(hotfix|alpha|beta) ]]; then
            ENVIRONMENT="staging"
            IS_PRERELEASE="true"
            echo "ðŸŽ¯ Target: staging (pre-release)" >> $GITHUB_STEP_SUMMARY
          else
            ENVIRONMENT="prod"
            IS_PRERELEASE="false"
            echo "ðŸŽ¯ Target: production (stable release)" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Set outputs
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release Summary:**" >> $GITHUB_STEP_SUMMARY
          echo "- Version: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- Type: $([ "$IS_PRERELEASE" == "true" ] && echo "Pre-release" || echo "Stable")" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

      - name: Create Tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Check if tag already exists
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $VERSION already exists" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create annotated tag
          git tag -a "$VERSION" -m "Release $VERSION

          Created: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Workflow: ${{ github.workflow }}  
          Run: ${{ github.run_id }}
          Triggered by: ${{ github.actor }}
          Target: ${{ steps.version.outputs.environment }}"
          
          # Push tag
          git push origin "$VERSION"
          echo "ðŸ·ï¸ Created and pushed tag: $VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Generate Release Notes
        id: notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          echo "## ðŸ“ Generating release notes" >> $GITHUB_STEP_SUMMARY
          
          # Create release notes
          NOTES_FILE="release-notes-$VERSION.md"
          
          cat > "$NOTES_FILE" << EOF
          # Release $VERSION
          
          **Target Environment**: ${{ steps.version.outputs.environment }}
          **Release Type**: ${{ steps.version.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable Release' }}
          **Created**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## Changes
          EOF
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "" >> "$NOTES_FILE"
            echo "### Commits since $PREVIOUS_TAG" >> "$NOTES_FILE"
            git log --pretty=format:"- %s (%h)" "$PREVIOUS_TAG..HEAD" >> "$NOTES_FILE" 2>/dev/null || echo "- Initial release" >> "$NOTES_FILE"
          else
            echo "- Initial release" >> "$NOTES_FILE"
          fi
          
          cat >> "$NOTES_FILE" << EOF
          
          ## Deployment
          This release will automatically deploy to **${{ steps.version.outputs.environment }}** environment.
          
          ## Build-Test-Run Pipeline
          The deployment follows our build-test-run strategy:
          1. **BUILD**: Code validation and artifact creation
          2. **TEST**: Quality gates and validation
          3. **RUN**: Deployment to ${{ steps.version.outputs.environment }}
          EOF
          
          echo "notes_file=$NOTES_FILE" >> $GITHUB_OUTPUT
          echo "âœ… Release notes generated" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const version = '${{ steps.version.outputs.version }}';
            const isPrerelease = '${{ steps.version.outputs.is_prerelease }}' === 'true';
            const notesFile = '${{ steps.notes.outputs.notes_file }}';
            
            // Read release notes
            const releaseNotes = fs.readFileSync(notesFile, 'utf8');
            
            try {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: version,
                name: version,
                body: releaseNotes,
                prerelease: isPrerelease,
                generate_release_notes: false
              });
              
              console.log(`âœ… Created GitHub release: ${release.data.html_url}`);
              
              // Add to step summary
              await core.summary
                .addHeading('ðŸŽ‰ GitHub Release Created')
                .addLink(`${version} Release`, release.data.html_url)
                .addRaw(`\n**Release URL**: ${release.data.html_url}`)
                .write();
            } catch (error) {
              console.log('âš ï¸ Release may already exist:', error.message);
            }

      - name: Trigger Build-Test-Run Pipeline
        if: |
          (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_after_tag != 'false')
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.version.outputs.version }}';
            const environment = '${{ steps.version.outputs.environment }}';
            
            console.log(`ðŸš€ Triggering deployment pipeline for ${version} to ${environment}`);
            
            try {
              // Trigger BUILD workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'build.yml',
                ref: context.ref,
                inputs: {
                  environment: environment,
                  force_build: 'true'
                }
              });
              
              console.log('âœ… BUILD workflow triggered');
              
              // Add to step summary
              await core.summary
                .addHeading('ðŸ”„ Pipeline Triggered')
                .addRaw(`**Version**: ${version}\n`)
                .addRaw(`**Environment**: ${environment}\n`)
                .addRaw(`**Pipeline**: BUILD â†’ TEST â†’ RUN\n`)
                .addRaw('\nMonitor progress in the Actions tab.')
                .write();
              
            } catch (error) {
              console.log('âŒ Failed to trigger pipeline:', error.message);
              core.setFailed(`Failed to trigger deployment pipeline: ${error.message}`);
            }

      - name: Release Summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“Š Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version Created | ${{ steps.version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Target Environment | ${{ steps.version.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| GitHub Release | ${{ job.status == 'success' && 'âœ… Created' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Pipeline Triggered | ${{ job.status == 'success' && 'âœ… Triggered' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "ðŸŽ‰ **RELEASE SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "Monitor the BUILD â†’ TEST â†’ RUN pipeline in the Actions tab." >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **RELEASE FAILED** - Check logs for details" >> $GITHUB_STEP_SUMMARY
          fi
