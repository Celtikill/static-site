name: RELEASE - Version Management and Deployment Orchestration

on:
  # Trigger on version tags
  push:
    tags:
      - 'v*.*.*'           # Production releases (v1.0.0)
      - 'v*.*.*-rc*'       # Release candidates (v1.0.0-rc1)
      - 'v*.*.*-hotfix.*'  # Hotfixes (v1.0.1-hotfix.1)
  
  # Manual release creation
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to create'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - rc
          - hotfix
      custom_version:
        description: 'Custom version (optional, overrides version_type)'
        required: false
        type: string
      deploy_to_staging:
        description: 'Deploy release candidate to staging'
        required: false
        default: true
        type: boolean
      deploy_to_production:
        description: 'Deploy stable release to production (requires approval)'
        required: false
        default: false
        type: boolean
      generate_release_notes:
        description: 'Auto-generate release notes from commits'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write
  actions: read
  id-token: write

jobs:
  # ==========================================
  # RELEASE INFO - Determine version and environment
  # ==========================================
  release-info:
    name: Determine Release Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      target_environment: ${{ steps.version.outputs.target_environment }}
      should_create_release: ${{ steps.version.outputs.should_create_release }}
      previous_version: ${{ steps.version.outputs.previous_version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0  # Full history for version calculation
          fetch-tags: true
      
      - name: Determine Version
        id: version
        run: |
          echo "ðŸ” Analyzing release trigger..."
          
          # If triggered by tag
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
            echo "ðŸ“Œ Using tag version: $VERSION"
          
          # If manual with custom version
          elif [[ -n "${{ github.event.inputs.custom_version }}" ]]; then
            VERSION="${{ github.event.inputs.custom_version }}"
            # Ensure version starts with 'v'
            if [[ ! "$VERSION" =~ ^v ]]; then
              VERSION="v$VERSION"
            fi
            echo "ðŸ“ Using custom version: $VERSION"
          
          # If manual with version type
          elif [[ -n "${{ github.event.inputs.version_type }}" ]]; then
            # Get latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "ðŸ“Š Latest tag: $LATEST_TAG"
            
            # Parse current version
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT_VERSION%%-*}"
            
            # Calculate new version based on type
            case "${{ github.event.inputs.version_type }}" in
              major)
                VERSION="v$((MAJOR + 1)).0.0"
                ;;
              minor)
                VERSION="v${MAJOR}.$((MINOR + 1)).0"
                ;;
              patch)
                VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
              rc)
                # Find next RC number
                RC_COUNT=$(git tag -l "v${MAJOR}.$((MINOR + 1)).0-rc*" | wc -l)
                VERSION="v${MAJOR}.$((MINOR + 1)).0-rc$((RC_COUNT + 1))"
                ;;
              hotfix)
                HOTFIX_COUNT=$(git tag -l "v${MAJOR}.${MINOR}.$((PATCH + 1))-hotfix.*" | wc -l)
                VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))-hotfix.$((HOTFIX_COUNT + 1))"
                ;;
            esac
            echo "ðŸ”¢ Calculated version: $VERSION"
          else
            echo "âŒ No version information provided"
            exit 1
          fi
          
          # Determine if prerelease
          if [[ "$VERSION" =~ -(rc|alpha|beta|hotfix) ]]; then
            IS_PRERELEASE="true"
            echo "ðŸ§ª This is a pre-release"
          else
            IS_PRERELEASE="false"
            echo "âœ… This is a stable release"
          fi
          
          # Determine target environment
          if [[ "$VERSION" =~ -rc ]]; then
            TARGET_ENV="staging"
            echo "ðŸŽ¯ Target environment: staging"
          elif [[ "$IS_PRERELEASE" == "false" ]]; then
            TARGET_ENV="prod"
            echo "ðŸŽ¯ Target environment: production"
          else
            TARGET_ENV="staging"
            echo "ðŸŽ¯ Target environment: staging (hotfix/beta)"
          fi
          
          # Get previous version for changelog
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "v0.0.0")
          echo "ðŸ“ˆ Previous version: $PREVIOUS_VERSION"
          
          # Set outputs
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "should_create_release=true" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          
          # Create summary
          echo "## ðŸ“¦ Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: $([ "$IS_PRERELEASE" == "true" ] && echo "Pre-release" || echo "Stable")" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: $TARGET_ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous**: $PREVIOUS_VERSION" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # CREATE TAG - If version doesn't exist
  # ==========================================
  create-tag:
    name: Create Version Tag
    runs-on: ubuntu-latest
    needs: release-info
    if: github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0
          fetch-tags: true
      
      - name: Check if Tag Exists
        id: check-tag
        run: |
          VERSION="${{ needs.release-info.outputs.version }}"
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $VERSION already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Tag $VERSION does not exist, will create"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create and Push Tag
        if: steps.check-tag.outputs.exists == 'false'
        run: |
          VERSION="${{ needs.release-info.outputs.version }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create annotated tag
          git tag -a "$VERSION" -m "Release $VERSION
          
          Created by: GitHub Actions
          Workflow: ${{ github.workflow }}
          Run: ${{ github.run_id }}
          Triggered by: ${{ github.actor }}"
          
          # Push tag
          git push origin "$VERSION"
          echo "ðŸ·ï¸ Created and pushed tag: $VERSION"

  # ==========================================
  # TRIGGER BUILD - Run BUILD workflow for new releases
  # ==========================================
  trigger-build:
    name: Trigger BUILD Workflow
    runs-on: ubuntu-latest
    needs: [release-info, create-tag]
    if: always() && needs.release-info.result == 'success'
    
    steps:
      - name: Trigger BUILD
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const version = '${{ needs.release-info.outputs.version }}';
            const environment = '${{ needs.release-info.outputs.target_environment }}';
            
            console.log(`ðŸ”¨ Triggering BUILD for ${version} targeting ${environment}`);
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build.yml',
              ref: context.ref,
              inputs: {
                environment: environment,
                force_build: 'true'
              }
            });
      
      - name: Wait for BUILD
        run: |
          echo "â³ Waiting 30 seconds for BUILD to start..."
          sleep 30

  # ==========================================
  # GENERATE RELEASE NOTES - Create changelog
  # ==========================================
  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: release-info
    if: github.event.inputs.generate_release_notes != 'false'
    outputs:
      release_notes: ${{ steps.notes.outputs.release_notes }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0
          fetch-tags: true
      
      - name: Generate Release Notes
        id: notes
        run: |
          VERSION="${{ needs.release-info.outputs.version }}"
          PREVIOUS="${{ needs.release-info.outputs.previous_version }}"
          
          echo "ðŸ“ Generating release notes from $PREVIOUS to $VERSION"
          
          # Create release notes file
          cat > RELEASE_NOTES.md << 'EOF'
          # Release Notes for ${{ needs.release-info.outputs.version }}
          
          ## ðŸ“… Release Date
          $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## ðŸŽ¯ Target Environment
          ${{ needs.release-info.outputs.target_environment }}
          
          ## ðŸ“Š Changes Summary
          EOF
          
          # Count changes by type
          FEATURES=$(git log $PREVIOUS..HEAD --grep="^feat" --oneline | wc -l)
          FIXES=$(git log $PREVIOUS..HEAD --grep="^fix" --oneline | wc -l)
          DOCS=$(git log $PREVIOUS..HEAD --grep="^docs" --oneline | wc -l)
          
          echo "- ðŸš€ Features: $FEATURES" >> RELEASE_NOTES.md
          echo "- ðŸ› Bug Fixes: $FIXES" >> RELEASE_NOTES.md
          echo "- ðŸ“š Documentation: $DOCS" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          
          # Add detailed changes
          echo "## ðŸš€ Features" >> RELEASE_NOTES.md
          git log $PREVIOUS..HEAD --grep="^feat" --pretty=format:"- %s (%h)" >> RELEASE_NOTES.md || echo "- No new features" >> RELEASE_NOTES.md
          echo -e "\n" >> RELEASE_NOTES.md
          
          echo "## ðŸ› Bug Fixes" >> RELEASE_NOTES.md
          git log $PREVIOUS..HEAD --grep="^fix" --pretty=format:"- %s (%h)" >> RELEASE_NOTES.md || echo "- No bug fixes" >> RELEASE_NOTES.md
          echo -e "\n" >> RELEASE_NOTES.md
          
          echo "## ðŸ“š Documentation" >> RELEASE_NOTES.md
          git log $PREVIOUS..HEAD --grep="^docs" --pretty=format:"- %s (%h)" >> RELEASE_NOTES.md || echo "- No documentation changes" >> RELEASE_NOTES.md
          echo -e "\n" >> RELEASE_NOTES.md
          
          echo "## ðŸ”§ Other Changes" >> RELEASE_NOTES.md
          git log $PREVIOUS..HEAD --grep -v "^feat\|^fix\|^docs" --pretty=format:"- %s (%h)" | head -10 >> RELEASE_NOTES.md
          echo -e "\n" >> RELEASE_NOTES.md
          
          # Add deployment instructions
          if [[ "${{ needs.release-info.outputs.target_environment }}" == "staging" ]]; then
            echo "## ðŸš€ Deployment Instructions" >> RELEASE_NOTES.md
            echo "This release candidate will be automatically deployed to staging for validation." >> RELEASE_NOTES.md
          elif [[ "${{ needs.release-info.outputs.target_environment }}" == "prod" ]]; then
            echo "## ðŸš€ Deployment Instructions" >> RELEASE_NOTES.md
            echo "This release requires approval before production deployment." >> RELEASE_NOTES.md
          fi
          
          # Save release notes to output
          NOTES=$(cat RELEASE_NOTES.md)
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also add to summary
          cat RELEASE_NOTES.md >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # CREATE GITHUB RELEASE - Create release in GitHub
  # ==========================================
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [release-info, generate-release-notes]
    if: always() && needs.release-info.outputs.should_create_release == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
      
      - name: Create Release
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const version = '${{ needs.release-info.outputs.version }}';
            const isPrerelease = ${{ needs.release-info.outputs.is_prerelease }};
            const environment = '${{ needs.release-info.outputs.target_environment }}';
            
            // Use generated notes or create default
            const releaseNotes = `${{ needs.generate-release-notes.outputs.release_notes }}` || 
              `Release ${version} for ${environment} environment`;
            
            try {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: version,
                name: `${version} - ${environment.toUpperCase()} Release`,
                body: releaseNotes,
                draft: false,
                prerelease: isPrerelease,
                target_commitish: context.sha
              });
              
              console.log(`âœ… Created GitHub release: ${release.data.html_url}`);
              
              // Add to summary
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `ðŸŽ‰ Release ${version} created: ${release.data.html_url}`
              });
            } catch (error) {
              if (error.status === 422) {
                console.log(`â„¹ï¸ Release ${version} already exists`);
              } else {
                throw error;
              }
            }

  # ==========================================
  # DEPLOY TO STAGING - For release candidates
  # ==========================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [release-info, trigger-build]
    if: |
      needs.release-info.outputs.target_environment == 'staging' &&
      (github.event.inputs.deploy_to_staging == 'true' || github.ref_type == 'tag')
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Trigger Staging Deployment
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const version = '${{ needs.release-info.outputs.version }}';
            
            console.log(`ðŸš€ Triggering staging deployment for ${version}`);
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy-staging.yml',
              ref: version,
              inputs: {
                skip_test_check: 'false',
                deploy_infrastructure: 'true',
                deploy_website: 'true'
              }
            });
            
            console.log(`âœ… Staging deployment triggered for ${version}`);

  # ==========================================
  # DEPLOY TO PRODUCTION - For stable releases
  # ==========================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [release-info, trigger-build]
    if: |
      needs.release-info.outputs.target_environment == 'prod' &&
      needs.release-info.outputs.is_prerelease == 'false' &&
      (github.event.inputs.deploy_to_production == 'true' || github.ref_type == 'tag')
    environment:
      name: production
      url: https://example.com
    
    steps:
      - name: Production Deployment Gate
        run: |
          echo "ðŸ” Production deployment requires approval"
          echo "Version: ${{ needs.release-info.outputs.version }}"
          echo "This step will wait for environment approval..."
      
      - name: Trigger Production Deployment
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const version = '${{ needs.release-info.outputs.version }}';
            
            console.log(`ðŸš€ Triggering production deployment for ${version}`);
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy.yml',
              ref: version,
              inputs: {
                environment: 'prod',
                skip_test_check: 'false',
                deploy_infrastructure: 'true',
                deploy_website: 'true'
              }
            });
            
            console.log(`âœ… Production deployment triggered for ${version}`);

  # ==========================================
  # UPDATE VERSION FILE - Track deployed versions
  # ==========================================
  update-version-tracking:
    name: Update Version Tracking
    runs-on: ubuntu-latest
    needs: [release-info, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update VERSION file
        run: |
          VERSION="${{ needs.release-info.outputs.version }}"
          ENVIRONMENT="${{ needs.release-info.outputs.target_environment }}"
          
          # Create or update VERSION file
          cat > terraform/VERSION << EOF
          environment: $ENVIRONMENT
          version: $VERSION
          deployed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          deployed_by: github-actions[bot]
          workflow_run: ${{ github.run_id }}
          commit: ${{ github.sha }}
          EOF
          
          echo "ðŸ“ Updated VERSION file for $ENVIRONMENT with $VERSION"
      
      - name: Commit Version Update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add terraform/VERSION
          git commit -m "chore: update VERSION file for ${{ needs.release-info.outputs.version }} deployment" || echo "No changes to commit"
          git push || echo "No changes to push"

  # ==========================================
  # RELEASE SUMMARY - Final status report
  # ==========================================
  release-summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [release-info, create-github-release, deploy-staging, deploy-production]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "# ðŸ“‹ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ“¦ Release Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.release-info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${{ needs.release-info.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.release-info.outputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ“Š Workflow Status" >> $GITHUB_STEP_SUMMARY
          echo "- Release Info: ${{ needs.release-info.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub Release: ${{ needs.create-github-release.result }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.release-info.outputs.target_environment }}" == "staging" ]]; then
            echo "- Staging Deployment: ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Production Deployment: ${{ needs.deploy-production.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ”— Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Release Page](https://github.com/${{ github.repository }}/releases/tag/${{ needs.release-info.outputs.version }})" >> $GITHUB_STEP_SUMMARY