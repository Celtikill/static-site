name: Deploy Composite - Reusable Deployment Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (dev, staging, prod)'
        required: true
        type: string
      ref:
        description: 'Git ref to deploy (commit SHA, branch, or tag)'
        required: true
        type: string
      tag:
        description: 'Optional tag to create for this deployment'
        required: false
        type: string
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        type: boolean
        default: true
      deploy_website:
        description: 'Deploy website content'
        required: false
        type: boolean
        default: true
      deployment_id:
        description: 'Unique deployment ID for idempotency'
        required: false
        type: string
    outputs:
      deployment_url:
        description: 'URL of the deployed website'
        value: ${{ jobs.website-deployment.outputs.deployment_url }}
      deployment_status:
        description: 'Status of the deployment'
        value: ${{ jobs.summary.outputs.status }}

permissions:
  id-token: write
  contents: read
  pull-requests: write
  deployments: write
  actions: read

env:
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
  OPENTOFU_VERSION: ${{ vars.OPENTOFU_VERSION }}
  TF_IN_AUTOMATION: true

jobs:
  setup:
    name: "ðŸ”§ Deployment Setup"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      deployment_id: ${{ steps.setup.outputs.deployment_id }}
      environment: ${{ steps.setup.outputs.environment }}
      account_id: ${{ steps.setup.outputs.account_id }}
    steps:
      - name: Setup Deployment
        id: setup
        run: |
          # Generate deployment ID if not provided
          if [ -z "${{ inputs.deployment_id }}" ]; then
            DEPLOYMENT_ID="deploy-${{ inputs.environment }}-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"
          else
            DEPLOYMENT_ID="${{ inputs.deployment_id }}"
          fi

          # Map environment to AWS account
          case "${{ inputs.environment }}" in
            dev)
              ACCOUNT_ID="822529998967"
              ;;
            staging)
              ACCOUNT_ID="927588814642"
              ;;
            prod)
              ACCOUNT_ID="546274483801"
              ;;
            *)
              echo "âŒ Unknown environment: ${{ inputs.environment }}"
              exit 1
              ;;
          esac

          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

          echo "# ðŸš€ Deployment Started" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment ID**: $DEPLOYMENT_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Account**: $ACCOUNT_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Ref**: ${{ inputs.ref }}" >> $GITHUB_STEP_SUMMARY

  infrastructure-deployment:
    name: "ðŸ—ï¸ Infrastructure Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: setup
    if: inputs.deploy_infrastructure
    outputs:
      terraform_outputs: ${{ steps.deploy.outputs.terraform_outputs }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Setup OpenTofu
        run: |
          curl -L -o /tmp/tofu.zip \
            https://github.com/opentofu/opentofu/releases/download/v${{ env.OPENTOFU_VERSION }}/tofu_${{ env.OPENTOFU_VERSION }}_linux_amd64.zip
          unzip -q /tmp/tofu.zip -d /tmp
          sudo mv /tmp/tofu /usr/local/bin/
          tofu version

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'dev' && secrets.AWS_ASSUME_ROLE_DEV || secrets.AWS_ASSUME_ROLE_MANAGEMENT }}
          role-session-name: github-actions-deploy-${{ github.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}
          audience: sts.amazonaws.com

      - name: Assume Target Account Role
        if: inputs.environment != 'dev'
        run: |
          # Install jq if not available
          which jq || sudo apt-get update && sudo apt-get install -y jq

          # For staging and production, assume cross-account role
          TARGET_ROLE="arn:aws:iam::${{ needs.setup.outputs.account_id }}:role/OrganizationAccountAccessRole"

          echo "Assuming role: $TARGET_ROLE"

          # Assume the target account role
          CREDS=$(aws sts assume-role \
            --role-arn "$TARGET_ROLE" \
            --role-session-name "github-deploy-${{ github.run_id }}" \
            --duration-seconds 3600)

          # Export new credentials
          export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')
          export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')
          export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')

          # Make credentials available to subsequent steps
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN" >> $GITHUB_ENV

          echo "âœ… Assumed role in account ${{ needs.setup.outputs.account_id }}"

      - name: Deploy Infrastructure
        id: deploy
        working-directory: terraform/workloads/static-site
        env:
          TARGET_ENV: ${{ needs.setup.outputs.environment }}
        run: |
          echo "## ðŸ—ï¸ Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY

          # Configure backend
          cat > backend_override.tf <<EOF
          terraform {
            backend "s3" {
              bucket         = "static-website-state-$TARGET_ENV"
              key            = "terraform.tfstate"
              region         = "${{ env.AWS_DEFAULT_REGION }}"
              dynamodb_table = "static-website-locks-$TARGET_ENV"
              encrypt        = true
            }
          }
          EOF

          # Initialize
          tofu init -reconfigure

          # Plan
          TFVARS_FILE="environments/$TARGET_ENV.tfvars"
          if [ -f "$TFVARS_FILE" ]; then
            tofu plan -var-file="$TFVARS_FILE" \
              -var="github_repository=${{ github.repository }}" \
              -out=deployment.tfplan
          else
            tofu plan -var="environment=$TARGET_ENV" \
              -var="github_repository=${{ github.repository }}" \
              -out=deployment.tfplan
          fi

          # Apply
          tofu apply -auto-approve deployment.tfplan

          # Get outputs
          TERRAFORM_OUTPUTS=$(tofu output -json)
          echo "terraform_outputs=$TERRAFORM_OUTPUTS" >> $GITHUB_OUTPUT

          echo "âœ… Infrastructure deployed successfully" >> $GITHUB_STEP_SUMMARY

  website-deployment:
    name: "ðŸŒ Website Content Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [setup, infrastructure-deployment]
    if: inputs.deploy_website
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_DEV }}
          role-session-name: github-actions-website-${{ github.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}
          audience: sts.amazonaws.com

      - name: Assume Target Account Role
        if: inputs.environment != 'dev'
        run: |
          # For staging and production, assume cross-account role
          TARGET_ROLE="arn:aws:iam::${{ needs.setup.outputs.account_id }}:role/OrganizationAccountAccessRole"

          echo "Assuming role: $TARGET_ROLE"

          # Assume the target account role
          CREDS=$(aws sts assume-role \
            --role-arn "$TARGET_ROLE" \
            --role-session-name "github-website-${{ github.run_id }}" \
            --duration-seconds 3600)

          # Export new credentials
          export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')
          export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')
          export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')

          # Make credentials available to subsequent steps
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN" >> $GITHUB_ENV

          echo "âœ… Assumed role in account ${{ needs.setup.outputs.account_id }}"

      - name: Deploy Website Content
        id: deploy
        env:
          TARGET_ENV: ${{ needs.setup.outputs.environment }}
        run: |
          echo "## ðŸŒ Website Content Deployment" >> $GITHUB_STEP_SUMMARY

          # Determine S3 bucket name
          S3_BUCKET="static-website-$TARGET_ENV"

          # Check if website content exists
          if [ -d "website/public" ]; then
            echo "Syncing website content to S3..." >> $GITHUB_STEP_SUMMARY

            # Sync website content
            aws s3 sync website/public/ s3://$S3_BUCKET/ \
              --delete \
              --cache-control "public, max-age=3600"

            # Invalidate CloudFront if exists
            DISTRIBUTION_ID=$(aws cloudfront list-distributions \
              --query "DistributionList.Items[?Comment=='Static Website $TARGET_ENV'].Id" \
              --output text 2>/dev/null || echo "")

            if [ -n "$DISTRIBUTION_ID" ]; then
              aws cloudfront create-invalidation \
                --distribution-id "$DISTRIBUTION_ID" \
                --paths "/*"
              echo "âœ… CloudFront cache invalidated" >> $GITHUB_STEP_SUMMARY
            fi

            # Get deployment URL
            if [ -n "$DISTRIBUTION_ID" ]; then
              DEPLOYMENT_URL=$(aws cloudfront get-distribution \
                --id "$DISTRIBUTION_ID" \
                --query "Distribution.DomainName" \
                --output text)
              DEPLOYMENT_URL="https://$DEPLOYMENT_URL"
            else
              DEPLOYMENT_URL="http://$S3_BUCKET.s3-website-${{ env.AWS_DEFAULT_REGION }}.amazonaws.com"
            fi

            echo "deployment_url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
            echo "âœ… Website deployed to: $DEPLOYMENT_URL" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ No website content found in website/public/" >> $GITHUB_STEP_SUMMARY
          fi

  summary:
    name: "ðŸ“Š Deployment Summary"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [setup, infrastructure-deployment, website-deployment]
    if: always()
    outputs:
      status: ${{ steps.summary.outputs.status }}
    steps:
      - name: Deployment Summary
        id: summary
        run: |
          echo "## ðŸ“Š Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check deployment status
          INFRA_STATUS="${{ needs.infrastructure-deployment.result }}"
          WEBSITE_STATUS="${{ needs.website-deployment.result }}"

          if [ "$INFRA_STATUS" = "success" ] || [ "$INFRA_STATUS" = "skipped" ]; then
            if [ "$WEBSITE_STATUS" = "success" ] || [ "$WEBSITE_STATUS" = "skipped" ]; then
              OVERALL_STATUS="success"
              echo "ðŸŽ‰ **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            else
              OVERALL_STATUS="partial"
              echo "âš ï¸ **PARTIAL DEPLOYMENT** - Infrastructure deployed, website failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            OVERALL_STATUS="failed"
            echo "âŒ **DEPLOYMENT FAILED**" >> $GITHUB_STEP_SUMMARY
          fi

          echo "status=$OVERALL_STATUS" >> $GITHUB_OUTPUT

          # Deployment details
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.deploy_infrastructure }}" = "true" ]; then
            if [ "$INFRA_STATUS" = "success" ]; then
              echo "| Infrastructure | âœ… Deployed |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Infrastructure | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Infrastructure | âž– Skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.deploy_website }}" = "true" ]; then
            if [ "$WEBSITE_STATUS" = "success" ]; then
              echo "| Website Content | âœ… Deployed |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Website Content | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Website Content | âž– Skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          # Add deployment URL if available
          if [ -n "${{ needs.website-deployment.outputs.deployment_url }}" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**ðŸŒ Deployment URL**: ${{ needs.website-deployment.outputs.deployment_url }}" >> $GITHUB_STEP_SUMMARY
          fi