name: RUN - Deployment Operations (Streamlined)

on:
  workflow_run:
    workflows: ["TEST - Quality Gates and Validation"]
    types: [completed]
    branches: [main, 'feature/*', 'bugfix/*', 'hotfix/*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [dev, staging, prod]
        default: dev
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        type: boolean
        default: true
      deploy_website:
        description: 'Deploy website content'
        required: false
        type: boolean
        default: true

permissions:
  id-token: write
  contents: read
  pull-requests: write
  deployments: write
  actions: read

env:
  # AWS Configuration
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION || 'us-east-1' }}
  MANAGEMENT_ACCOUNT_ID: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
  AWS_ACCOUNT_ID_DEV: ${{ vars.AWS_ACCOUNT_ID_DEV }}
  AWS_ACCOUNT_ID_STAGING: ${{ vars.AWS_ACCOUNT_ID_STAGING }}
  AWS_ACCOUNT_ID_PROD: ${{ vars.AWS_ACCOUNT_ID_PROD }}

  # Project Identity (use built-in GitHub context vars)
  REPO_FULL_NAME: ${{ github.repository }}
  REPO_OWNER: ${{ github.repository_owner }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME }}
  PROJECT_SHORT_NAME: ${{ vars.PROJECT_SHORT_NAME }}
  EXTERNAL_ID: ${{ vars.EXTERNAL_ID }}

  # Infrastructure Tools
  OPENTOFU_VERSION: ${{ vars.OPENTOFU_VERSION || '1.8.4' }}
  TF_IN_AUTOMATION: true
  TF_CLI_ARGS: "-no-color"
  NO_COLOR: 1

  # Terraform Variables (pass to Terraform via TF_VAR_ prefix)
  TF_VAR_project_name: ${{ vars.PROJECT_NAME }}

concurrency:
  # Ensure per-environment serialization to prevent Terraform state lock conflicts
  # Manual dispatches use selected environment, automatic runs route by branch
  # main â†’ staging, feature/* â†’ dev
  group: deploy-${{ inputs.environment || github.event.workflow_run.head_branch || 'dev' }}
  cancel-in-progress: false

jobs:
  info:
    name: "ðŸ“‹ Deployment Information"
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      target_environment: ${{ steps.info.outputs.target_environment }}
      commit_sha: ${{ steps.info.outputs.commit_sha }}
      deploy_infrastructure: ${{ steps.info.outputs.deploy_infrastructure }}
      deploy_website: ${{ steps.info.outputs.deploy_website }}
      run_id: ${{ steps.info.outputs.run_id }}
    steps:
      - name: Determine Deployment Info
        id: info
        run: |
          RUN_ID="run-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TARGET_ENV="${{ inputs.environment }}"
            COMMIT_SHA="${{ github.sha }}"
            # Convert boolean inputs to string values
            if [ "${{ inputs.deploy_infrastructure }}" = "true" ]; then
              DEPLOY_INFRA="true"
            else
              DEPLOY_INFRA="false"
            fi

            if [ "${{ inputs.deploy_website }}" = "true" ]; then
              DEPLOY_WEBSITE="true"
            else
              DEPLOY_WEBSITE="false"
            fi
            TRIGGER_SOURCE="manual dispatch"
          else
            # Triggered by TEST workflow completion
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]
            then
              echo "âŒ TEST workflow failed - aborting deployment"
              exit 1
            fi

            # Environment routing based on branch
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            case "$BRANCH" in
              main)
                # Main branch auto-deploys to staging environment
                TARGET_ENV="staging"
                echo "â„¹ï¸ Main branch deployment to staging environment"
                ;;
              feature/*|bugfix/*|hotfix/*|develop)
                # Development branches deploy to dev environment
                TARGET_ENV="dev"
                echo "â„¹ï¸ Development branch deployment to dev environment"
                ;;
              *)
                # Default to dev for any other branch
                TARGET_ENV="dev"
                echo "â„¹ï¸ Default deployment to dev environment"
                ;;
            esac

            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            DEPLOY_INFRA="true"
            DEPLOY_WEBSITE="true"
            TRIGGER_SOURCE="automatic via TEST workflow"
          fi

          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          # Ensure boolean values are properly formatted for output
          echo "deploy_infrastructure=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
          echo "deploy_website=$DEPLOY_WEBSITE" >> $GITHUB_OUTPUT
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT

          echo "# ðŸš€ RUN Phase - Streamlined" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $TARGET_ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: $TRIGGER_SOURCE" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Infrastructure**: $DEPLOY_INFRA" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Website**: $DEPLOY_WEBSITE" >> $GITHUB_STEP_SUMMARY

  authorization:
    name: "ðŸ” Production Authorization"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: info
    if: needs.info.outputs.target_environment == 'prod'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Production Authorization
        run: |
          echo "ðŸ” **Production Deployment Authorization**" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "âŒ Production deployments require manual authorization"
            echo "Use: gh workflow run run-streamlined.yml"
            exit 1
          fi

          echo "âœ… **AUTHORIZED**: Manual production deployment" >> \
            $GITHUB_STEP_SUMMARY

  setup:
    name: "âš™ï¸ Setup AWS Authentication"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, authorization]
    if: always() && needs.info.result == 'success' && (needs.authorization.result == 'success' || needs.authorization.result == 'skipped')
    outputs:
      target_role_arn: ${{ steps.config.outputs.target_role_arn }}
      aws_region: ${{ steps.config.outputs.aws_region }}
    steps:
      - name: Configure Environment-Specific Authentication
        id: config
        run: |
          TARGET_ENV="${{ needs.info.outputs.target_environment }}"

          # Environment-specific role mapping
          PROJECT_SHORT_NAME="${{ vars.PROJECT_SHORT_NAME }}"
          case "$TARGET_ENV" in
            dev)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_DEV }}:role/GitHubActions-${PROJECT_SHORT_NAME}-Dev-Role"
              AWS_REGION="${{ vars.AWS_DEFAULT_REGION }}"
              ;;
            staging)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_STAGING }}:role/GitHubActions-${PROJECT_SHORT_NAME}-Staging-Role"
              AWS_REGION="${{ vars.AWS_DEFAULT_REGION }}"
              ;;
            prod)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_PROD }}:role/GitHubActions-${PROJECT_SHORT_NAME}-Prod-Role"
              AWS_REGION="${{ vars.AWS_DEFAULT_REGION }}"
              ;;
            *)
              echo "âŒ Invalid environment: $TARGET_ENV"
              exit 1
              ;;
          esac

          echo "target_role_arn=$TARGET_ROLE" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT

          echo "ðŸ” **Environment Authentication Setup**" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $TARGET_ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Role**: $TARGET_ROLE" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region**: $AWS_REGION" >> $GITHUB_STEP_SUMMARY

  deploy_infrastructure:
    name: "ðŸ—ï¸ Infrastructure Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [info, setup]
    if: always() && needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_infrastructure == 'true'
    env:
      # Configure Terraform state lock timeout (5 minutes)
      TF_LOCK_TIMEOUT: 5m
    outputs:
      deployment_status: ${{ steps.deploy.outputs.deployment_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.info.outputs.commit_sha }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.target_role_arn }}
          role-session-name: github-actions-${{ needs.info.outputs.target_environment }}-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.aws_region }}
          audience: sts.amazonaws.com

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}

      - name: Deploy Infrastructure
        id: deploy
        working-directory: terraform/environments/${{ needs.info.outputs.target_environment }}
        run: |
          # Enable strict error handling - any command failure will exit the script
          set -euo pipefail

          # Trap errors and ensure they're logged
          trap 'echo "::error::Script failed at line $LINENO with exit code $?"' ERR

          echo "ðŸ—ï¸ **Infrastructure Deployment**" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.info.outputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ needs.info.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=3
            local timeout_duration=$1
            local attempt=1
            local delay=10
            shift

            while [ $attempt -le $max_attempts ]; do
              echo "â³ Attempt $attempt/$max_attempts..."

              # Run command with timeout and capture exit code properly
              set +e  # Temporarily disable exit-on-error to capture exit code
              timeout ${timeout_duration}s "$@"
              local exit_code=$?
              set -e  # Re-enable exit-on-error

              if [ $exit_code -eq 0 ]; then
                echo "âœ… Command succeeded on attempt $attempt"
                return 0
              fi

              if [ $exit_code -eq 124 ]; then
                echo "âš ï¸ Command timed out after ${timeout_duration}s"
              else
                echo "âš ï¸ Command failed with exit code $exit_code"
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "â³ Waiting ${delay}s before retry..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff
                attempt=$((attempt + 1))
              else
                echo "âŒ All retry attempts exhausted, final exit code: $exit_code"
                # Ensure we return non-zero on failure
                return $exit_code
              fi
            done
            # Should never reach here, but return failure if we do
            return 1
          }

          # Terraform plan+apply retry function (creates fresh plan each attempt)
          retry_terraform_deployment() {
            local max_attempts=3
            local attempt=1
            local delay=10

            while [ $attempt -le $max_attempts ]; do
              echo "ðŸ”„ Terraform deployment attempt $attempt/$max_attempts..."

              # Create fresh plan on each attempt (prevents stale plan errors)
              echo "ðŸ“‹ Creating deployment plan (attempt $attempt)..."
              set +e
              timeout 300s tofu plan -no-color -out=deployment-attempt-$attempt.tfplan
              local plan_exit=$?
              set -e

              if [ $plan_exit -ne 0 ]; then
                if [ $plan_exit -eq 124 ]; then
                  echo "âš ï¸ Plan timed out after 300s"
                else
                  echo "âš ï¸ Plan failed with exit code $plan_exit"
                fi

                if [ $attempt -lt $max_attempts ]; then
                  echo "â³ Waiting ${delay}s before retry..."
                  sleep $delay
                  delay=$((delay * 2))
                  attempt=$((attempt + 1))
                  continue
                else
                  echo "âŒ All plan attempts exhausted"
                  return $plan_exit
                fi
              fi

              # Apply the fresh plan
              echo "ðŸš€ Applying infrastructure changes (attempt $attempt)..."
              set +e
              timeout 180s tofu apply -no-color -auto-approve deployment-attempt-$attempt.tfplan
              local apply_exit=$?
              set -e

              if [ $apply_exit -eq 0 ]; then
                echo "âœ… Apply succeeded on attempt $attempt"
                return 0
              fi

              if [ $apply_exit -eq 124 ]; then
                echo "âš ï¸ Apply timed out after 180s"
              else
                echo "âš ï¸ Apply failed with exit code $apply_exit"
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "â³ Waiting ${delay}s before retry..."
                sleep $delay
                delay=$((delay * 2))
                attempt=$((attempt + 1))
              else
                echo "âŒ All apply attempts exhausted"
                return $apply_exit
              fi
            done

            # Should never reach here
            return 1
          }

          # Construct dynamic backend configuration (fork-friendly)
          TARGET_ENV="${{ needs.info.outputs.target_environment }}"

          # Get account ID for target environment
          case "$TARGET_ENV" in
            dev) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_DEV }}" ;;
            staging) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_STAGING }}" ;;
            prod) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_PROD }}" ;;
          esac

          # Construct bucket name using PROJECT_NAME (matches bootstrap script)
          STATE_BUCKET="${{ vars.PROJECT_NAME }}-state-${TARGET_ENV}-${ACCOUNT_ID}"
          LOCK_TABLE="${{ vars.PROJECT_NAME }}-locks-${TARGET_ENV}"

          echo "ðŸ”§ Backend Configuration:" >> $GITHUB_STEP_SUMMARY
          echo "- Bucket: \`${STATE_BUCKET}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Lock Table: \`${LOCK_TABLE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Region: \`${{ vars.AWS_DEFAULT_REGION }}\`" >> $GITHUB_STEP_SUMMARY

          # Initialize Terraform with dynamic backend configuration
          echo "ðŸ”§ Initializing with backend configuration..."
          timeout 90s tofu init -no-color \
            -backend-config="bucket=${STATE_BUCKET}" \
            -backend-config="key=environments/${TARGET_ENV}/terraform.tfstate" \
            -backend-config="region=${{ vars.AWS_DEFAULT_REGION }}" \
            -backend-config="dynamodb_table=${LOCK_TABLE}" \
            -backend-config="encrypt=true"

          # Check for existing KMS alias and import if needed (prevents AlreadyExistsException)
          echo "ðŸ” Checking for existing KMS alias..."
          KMS_ALIAS="alias/${PROJECT_NAME}-${TARGET_ENV}"

          # Check if alias exists in AWS
          if aws kms describe-alias --alias-name "$KMS_ALIAS" --region "${AWS_REGION}" 2>/dev/null; then
            echo "ðŸ“¦ KMS alias $KMS_ALIAS exists in AWS"

            # Check if it's in Terraform state
            if ! tofu state show 'module.static_website.aws_kms_alias.main[0]' 2>/dev/null; then
              echo "ðŸ“¥ Importing existing KMS alias into Terraform state..."
              if tofu import 'module.static_website.aws_kms_alias.main[0]' "$KMS_ALIAS"; then
                echo "âœ… KMS alias imported successfully"
              else
                echo "âš ï¸ Failed to import KMS alias, deployment may encounter issues"
              fi
            else
              echo "âœ… KMS alias already in Terraform state"
            fi
          else
            echo "â„¹ï¸ KMS alias does not exist, will be created"
          fi

          # Deploy infrastructure with integrated plan+apply retry logic
          echo "ðŸš€ Starting infrastructure deployment..."
          if ! retry_terraform_deployment; then
            EXIT_CODE=$?
            echo "âŒ Failed to deploy infrastructure (exit code: $EXIT_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
            echo "::error::Terraform deployment failed with exit code $EXIT_CODE"
            exit 1
          fi
          echo "âœ… Infrastructure deployment completed successfully" >> $GITHUB_STEP_SUMMARY

          # Get outputs (filter out warnings)
          echo "ðŸ“Š Retrieving infrastructure outputs..."
          BUCKET_NAME=$(tofu output -raw s3_bucket_name 2>&1 | grep -v "Warning:" | head -n1 || echo "")
          CLOUDFRONT_ID=$(tofu output -raw cloudfront_distribution_id 2>&1 | grep -v "Warning:" | head -n1 || echo "")
          WEBSITE_URL=$(tofu output -raw website_url 2>&1 | grep -v "Warning:" | head -n1 || echo "")

          # Validate critical outputs exist
          if [ -z "$BUCKET_NAME" ]; then
            echo "::error::Critical output missing: s3_bucket_name is empty"
            echo "âŒ Infrastructure deployment incomplete - S3 bucket not created" >> $GITHUB_STEP_SUMMARY
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "deployment_status=success" >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_ENV
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_ENV
          echo "website_url=$WEBSITE_URL" >> $GITHUB_ENV

          echo "âœ… Infrastructure deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket**: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
          if [ -n "$WEBSITE_URL" ]; then
            echo "- **Website URL**: $WEBSITE_URL" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "$CLOUDFRONT_ID" ]; then
            echo "- **CloudFront ID**: $CLOUDFRONT_ID" >> $GITHUB_STEP_SUMMARY
          fi

  deploy_website:
    name: "ðŸŒ Website Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, setup, deploy_infrastructure]
    if: always() && needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_website == 'true' && (needs.deploy_infrastructure.result == 'success' || needs.deploy_infrastructure.result == 'skipped')
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
      cloudfront_url: ${{ steps.deploy.outputs.cloudfront_url }}
      s3_endpoint: ${{ steps.deploy.outputs.s3_endpoint }}
      dashboard_url: ${{ steps.deploy.outputs.dashboard_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.info.outputs.commit_sha }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.target_role_arn }}
          role-session-name: github-actions-${{ needs.info.outputs.target_environment }}-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.aws_region }}
          audience: sts.amazonaws.com

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}

      - name: Deploy Website Content
        id: deploy
        run: |
          # Enable strict error handling
          set -euo pipefail

          echo "ðŸŒ **Website Deployment**" >> $GITHUB_STEP_SUMMARY

          # Get infrastructure outputs using dynamic backend configuration
          cd terraform/environments/${{ needs.info.outputs.target_environment }}

          # Construct dynamic backend configuration (fork-friendly)
          TARGET_ENV="${{ needs.info.outputs.target_environment }}"

          # Get account ID for target environment
          case "$TARGET_ENV" in
            dev) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_DEV }}" ;;
            staging) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_STAGING }}" ;;
            prod) ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_PROD }}" ;;
          esac

          # Construct bucket name using PROJECT_NAME (matches bootstrap script)
          STATE_BUCKET="${{ vars.PROJECT_NAME }}-state-${TARGET_ENV}-${ACCOUNT_ID}"
          LOCK_TABLE="${{ vars.PROJECT_NAME }}-locks-${TARGET_ENV}"

          # Initialize to read outputs using dynamic backend config
          timeout 60s tofu init -no-color \
            -backend-config="bucket=${STATE_BUCKET}" \
            -backend-config="key=environments/${TARGET_ENV}/terraform.tfstate" \
            -backend-config="region=${{ vars.AWS_DEFAULT_REGION }}" \
            -backend-config="dynamodb_table=${LOCK_TABLE}" \
            -backend-config="encrypt=true"

          # Refresh state to ensure latest infrastructure outputs are available
          echo "ðŸ”„ Refreshing state to sync with infrastructure deployment..."
          timeout 60s tofu refresh -no-color

          # Get outputs using JSON format for reliable parsing
          # JSON format handles null values properly and avoids GitHub Actions wrapper issues
          OUTPUT_JSON=$(tofu output -no-color -json)

          # Parse individual outputs from JSON, handling null values properly
          BUCKET_NAME=$(echo "$OUTPUT_JSON" | jq -r '.s3_bucket_id.value // empty')
          WEBSITE_URL=$(echo "$OUTPUT_JSON" | jq -r '.website_url.value // empty')
          S3_ENDPOINT=$(echo "$OUTPUT_JSON" | jq -r '.s3_bucket_domain_name.value // empty')
          DASHBOARD_URL=$(echo "$OUTPUT_JSON" | jq -r '.cloudwatch_dashboard_url.value // empty')

          # CloudFront outputs may be null in cost-optimized deployments
          CLOUDFRONT_ID=$(echo "$OUTPUT_JSON" | jq -r '.cloudfront_distribution_id.value // empty' | grep -v "^null$" || echo "")
          CLOUDFRONT_URL=$(echo "$OUTPUT_JSON" | jq -r '.cloudfront_url.value // empty' | grep -v "^null$" || echo "")

          echo "- **S3 Bucket**: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFront ID**: $CLOUDFRONT_ID" >> $GITHUB_STEP_SUMMARY

          # Sync website content
          echo "ðŸ“¤ Syncing website content to S3..."
          timeout 120s aws s3 sync ../../../src/ s3://$BUCKET_NAME --delete --sse AES256

          # Invalidate CloudFront cache if distribution exists
          if [ -n "$CLOUDFRONT_ID" ]; then
            echo "ðŸ”„ Invalidating CloudFront cache..."
            timeout 60s aws cloudfront create-invalidation \
              --distribution-id $CLOUDFRONT_ID \
              --paths "/*"
          else
            echo "â„¹ï¸ No CloudFront distribution to invalidate (cost-optimized S3-only deployment)"
          fi

          echo "deployment_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          echo "cloudfront_url=$CLOUDFRONT_URL" >> $GITHUB_OUTPUT
          echo "s3_endpoint=$S3_ENDPOINT" >> $GITHUB_OUTPUT
          echo "dashboard_url=$DASHBOARD_URL" >> $GITHUB_OUTPUT

          echo "âœ… Website deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š See final summary for deployment URLs" >> $GITHUB_STEP_SUMMARY

  validation:
    name: "âœ… Post-Deployment Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, deploy_infrastructure, deploy_website]
    if: always() && (needs.deploy_infrastructure.result == 'success' || needs.deploy_website.result == 'success')
    steps:
      - name: Health Check
        run: |
          echo "âœ… **Post-Deployment Validation**" >> $GITHUB_STEP_SUMMARY

          WEBSITE_URL="${{ needs.deploy_website.outputs.deployment_url }}"
          CLOUDFRONT_URL="${{ needs.deploy_website.outputs.cloudfront_url }}"
          S3_ENDPOINT="${{ needs.deploy_website.outputs.s3_endpoint }}"
          DASHBOARD_URL="${{ needs.deploy_website.outputs.dashboard_url }}"

          if [ -n "$WEBSITE_URL" ]; then
            echo "ðŸ” Testing website accessibility..."

            # Test website accessibility
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEBSITE_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Website is accessible (HTTP $HTTP_STATUS)" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ Website returned HTTP $HTTP_STATUS" >> $GITHUB_STEP_SUMMARY
            fi
            echo "ðŸ“Š See final summary for deployment URLs" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸ No website URL available for validation" >> $GITHUB_STEP_SUMMARY
          fi

          echo "âœ… Post-deployment validation completed" >> $GITHUB_STEP_SUMMARY

  summary:
    name: "ðŸ“Š Deployment Summary"
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [info, deploy_infrastructure, deploy_website, validation, update_readme]
    if: always()
    steps:
      - name: Final Summary
        run: |
          # URL normalization function - ensures all URLs have protocol prefix
          normalize_url() {
            local url="$1"
            if [ -z "$url" ]; then
              echo ""
              return
            fi
            # If URL doesn't start with http:// or https://, add http://
            if [[ ! "$url" =~ ^https?:// ]]; then
              echo "http://$url"
            else
              echo "$url"
            fi
          }

          echo "## ðŸ“Š Final Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.info.outputs.target_environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy_infrastructure.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Website | ${{ needs.deploy_website.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validation.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY

          # Normalize URLs to ensure they have protocols
          DEPLOY_URL=$(normalize_url "${{ needs.deploy_website.outputs.deployment_url }}")
          CLOUDFRONT_URL=$(normalize_url "${{ needs.deploy_website.outputs.cloudfront_url }}")
          S3_ENDPOINT=$(normalize_url "${{ needs.deploy_website.outputs.s3_endpoint }}")
          DASHBOARD_URL=$(normalize_url "${{ needs.deploy_website.outputs.dashboard_url }}")

          if [ -n "$DEPLOY_URL" ]; then
            echo "| Primary URL | [$DEPLOY_URL]($DEPLOY_URL) |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$CLOUDFRONT_URL" ]; then
            echo "| CloudFront URL | [$CLOUDFRONT_URL]($CLOUDFRONT_URL) |" >> $GITHUB_STEP_SUMMARY
            echo "| Architecture | CloudFront + S3 (full stack) |" >> $GITHUB_STEP_SUMMARY
            echo "| Cost Profile | ~\$20-35/month |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| CloudFront URL | Disabled (cost optimization) |" >> $GITHUB_STEP_SUMMARY
            echo "| Architecture | S3-only (cost optimized) |" >> $GITHUB_STEP_SUMMARY
            echo "| Cost Profile | ~\$1-5/month |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$DASHBOARD_URL" ]; then
            echo "| Monitoring | [$DASHBOARD_URL]($DASHBOARD_URL) |" >> $GITHUB_STEP_SUMMARY
          fi

          # Final status determination
          INFRA_SUCCESS="${{ needs.deploy_infrastructure.result }}"
          WEBSITE_SUCCESS="${{ needs.deploy_website.result }}"

          if [[ "$INFRA_SUCCESS" == "success" || "$INFRA_SUCCESS" == "skipped" ]] && \
             [[ "$WEBSITE_SUCCESS" == "success" || "$WEBSITE_SUCCESS" == "skipped" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸŽ‰ **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            if [ -n "$DEPLOY_URL" ]; then
              echo "ðŸŒ **Visit**: $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
              if [ -n "$CLOUDFRONT_URL" ]; then
                echo "âš¡ **CDN**: $CLOUDFRONT_URL (Global distribution)" >> $GITHUB_STEP_SUMMARY
              else
                echo "ðŸ’° **Cost Optimized**: S3-only deployment (~\$1-5/month savings)" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **DEPLOYMENT FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "Check the deployment job logs for details" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  update_readme:
    name: "ðŸ“ Update README Deployment Status"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, deploy_website, validation]
    if: needs.deploy_website.result == 'success' && needs.deploy_website.outputs.deployment_url != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update README with Deployment URLs
        run: |
          echo "ðŸ“ **Updating README with deployment information**" >> $GITHUB_STEP_SUMMARY

          TARGET_ENV="${{ needs.info.outputs.target_environment }}"
          DEPLOY_URL="${{ needs.deploy_website.outputs.deployment_url }}"
          CLOUDFRONT_URL="${{ needs.deploy_website.outputs.cloudfront_url }}"
          DASHBOARD_URL="${{ needs.deploy_website.outputs.dashboard_url }}"
          TIMESTAMP=$(date -u "+%Y-%m-%d %H:%M:%S UTC")

          # Determine architecture and cost profile
          if [ -n "$CLOUDFRONT_URL" ]; then
            ARCHITECTURE="CloudFront + S3 (full stack)"
            COST_PROFILE="~\$20-35/month"
          else
            ARCHITECTURE="S3-only (cost optimized)"
            COST_PROFILE="~\$1-5/month"
          fi

          # Determine account ID based on environment
          case "$TARGET_ENV" in
            dev)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_DEV }}"
              ;;
            staging)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_STAGING }}"
              ;;
            prod)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_PROD }}"
              ;;
            *)
              ACCOUNT_ID="unknown"
              ;;
          esac

          # Create temporary file with updated environment section
          ENV_NAME="$(echo "$TARGET_ENV" | sed 's/./\U&/') Environment"
          {
            echo "**ENV_PLACEHOLDER** âœ… OPERATIONAL"
            echo "- URL: URL_PLACEHOLDER"
            echo "- Architecture: ARCHITECTURE_PLACEHOLDER"
            echo "- Cost Profile: COST_PLACEHOLDER"
            echo "- Last Updated: TIMESTAMP_PLACEHOLDER"
            echo "- Account: ACCOUNT_PLACEHOLDER"
            echo "MONITORING_PLACEHOLDER"
            echo ""
          } > /tmp/env_section.txt

          # Use sed to substitute variables in the template
          sed -i "s/ENV_PLACEHOLDER/$ENV_NAME/g" /tmp/env_section.txt
          sed -i "s|URL_PLACEHOLDER|$DEPLOY_URL|g" /tmp/env_section.txt
          sed -i "s/ARCHITECTURE_PLACEHOLDER/$ARCHITECTURE/g" /tmp/env_section.txt
          sed -i "s/COST_PLACEHOLDER/$COST_PROFILE/g" /tmp/env_section.txt
          sed -i "s/TIMESTAMP_PLACEHOLDER/$TIMESTAMP/g" /tmp/env_section.txt
          sed -i "s/ACCOUNT_PLACEHOLDER/$ACCOUNT_ID/g" /tmp/env_section.txt

          # Add monitoring line if dashboard URL exists
          if [ -n "$DASHBOARD_URL" ]; then
            sed -i "s/MONITORING_PLACEHOLDER/\\n- Monitoring: $DASHBOARD_URL/g" /tmp/env_section.txt
          else
            sed -i "s/MONITORING_PLACEHOLDER//g" /tmp/env_section.txt
          fi

          # Update README by replacing the environment section
          SECTION_PATTERN="**$(echo "$TARGET_ENV" | sed 's/./\U&/') Environment**"

          # Find the line numbers for the section
          START_LINE=$(grep -n "$SECTION_PATTERN" README.md | cut -d: -f1)

          if [ -n "$START_LINE" ]; then
            # Find the end of the section (next ** heading or end of file)
            END_LINE=$(tail -n +$((START_LINE + 1)) README.md | grep -n "^##\|^\*\*" | head -1 | cut -d: -f1)

            if [ -n "$END_LINE" ]; then
              END_LINE=$((START_LINE + END_LINE - 1))
            else
              END_LINE=$(wc -l < README.md)
            fi

            # Replace the section
            head -n $((START_LINE - 1)) README.md > /tmp/readme_new.md
            cat /tmp/env_section.txt >> /tmp/readme_new.md
            tail -n +$((END_LINE + 1)) README.md >> /tmp/readme_new.md
            mv /tmp/readme_new.md README.md
          fi

          echo "âœ… README updated for $TARGET_ENV environment" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: $ARCHITECTURE" >> $GITHUB_STEP_SUMMARY
          echo "- **Cost Profile**: $COST_PROFILE" >> $GITHUB_STEP_SUMMARY

      - name: Commit README Updates
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if git diff --quiet README.md; then
            echo "â„¹ï¸ No changes to README.md" >> $GITHUB_STEP_SUMMARY
          else
            git add README.md
            git commit -m "ðŸŒ Update ${{ needs.info.outputs.target_environment }} deployment URLs ðŸ¤– Generated with Claude Code"
            git push
            echo "âœ… README.md updated and committed" >> $GITHUB_STEP_SUMMARY
          fi
