name: RUN - Deployment Operations (Streamlined)

on:
  workflow_run:
    workflows: ["TEST - Quality Gates and Validation"]
    types: [completed]
    branches: [main, 'feature/*', 'bugfix/*', 'hotfix/*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [dev, staging, prod]
        default: dev
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        type: boolean
        default: true
      deploy_website:
        description: 'Deploy website content'
        required: false
        type: boolean
        default: true

permissions:
  id-token: write
  contents: read
  pull-requests: write
  deployments: write
  actions: read

env:
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
  OPENTOFU_VERSION: ${{ vars.OPENTOFU_VERSION }}
  TF_IN_AUTOMATION: true
  TF_CLI_ARGS: "-no-color"
  NO_COLOR: 1

concurrency:
  group: run-${{ inputs.environment || 'auto' }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  info:
    name: "üìã Deployment Information"
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      target_environment: ${{ steps.info.outputs.target_environment }}
      commit_sha: ${{ steps.info.outputs.commit_sha }}
      deploy_infrastructure: ${{ steps.info.outputs.deploy_infrastructure }}
      deploy_website: ${{ steps.info.outputs.deploy_website }}
      run_id: ${{ steps.info.outputs.run_id }}
    steps:
      - name: Determine Deployment Info
        id: info
        run: |
          RUN_ID="run-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TARGET_ENV="${{ inputs.environment }}"
            COMMIT_SHA="${{ github.sha }}"
            # Convert boolean inputs to string values
            if [ "${{ inputs.deploy_infrastructure }}" = "true" ]; then
              DEPLOY_INFRA="true"
            else
              DEPLOY_INFRA="false"
            fi

            if [ "${{ inputs.deploy_website }}" = "true" ]; then
              DEPLOY_WEBSITE="true"
            else
              DEPLOY_WEBSITE="false"
            fi
            TRIGGER_SOURCE="manual dispatch"
          else
            # Triggered by TEST workflow completion
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]
            then
              echo "‚ùå TEST workflow failed - aborting deployment"
              exit 1
            fi

            # Environment routing based on branch
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            case "$BRANCH" in
              main)
                # Main branch auto-deploys to dev environment
                TARGET_ENV="dev"
                echo "‚ÑπÔ∏è Main branch deployment to dev environment"
                ;;
              feature/*|bugfix/*|hotfix/*)
                # Feature branches deploy to dev environment
                TARGET_ENV="dev"
                echo "‚ÑπÔ∏è Feature branch deployment to dev environment"
                ;;
              *)
                # Default to dev for any other branch
                TARGET_ENV="dev"
                echo "‚ÑπÔ∏è Default deployment to dev environment"
                ;;
            esac

            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            DEPLOY_INFRA="true"
            DEPLOY_WEBSITE="true"
            TRIGGER_SOURCE="automatic via TEST workflow"
          fi

          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          # Ensure boolean values are properly formatted for output
          echo "deploy_infrastructure=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
          echo "deploy_website=$DEPLOY_WEBSITE" >> $GITHUB_OUTPUT
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT

          echo "# üöÄ RUN Phase - Streamlined" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $TARGET_ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: $TRIGGER_SOURCE" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Infrastructure**: $DEPLOY_INFRA" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Website**: $DEPLOY_WEBSITE" >> $GITHUB_STEP_SUMMARY

  authorization:
    name: "üîê Production Authorization"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: info
    if: needs.info.outputs.target_environment == 'prod'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Production Authorization
        run: |
          echo "üîê **Production Deployment Authorization**" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "‚ùå Production deployments require manual authorization"
            echo "Use: gh workflow run run-streamlined.yml"
            exit 1
          fi

          echo "‚úÖ **AUTHORIZED**: Manual production deployment" >> \
            $GITHUB_STEP_SUMMARY

  setup:
    name: "‚öôÔ∏è Setup AWS Authentication"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, authorization]
    if: always() && needs.info.result == 'success' && (needs.authorization.result == 'success' || needs.authorization.result == 'skipped')
    outputs:
      target_role_arn: ${{ steps.config.outputs.target_role_arn }}
      aws_region: ${{ steps.config.outputs.aws_region }}
    steps:
      - name: Configure Environment-Specific Authentication
        id: config
        run: |
          TARGET_ENV="${{ needs.info.outputs.target_environment }}"

          # Environment-specific role mapping
          case "$TARGET_ENV" in
            dev)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_DEV }}:role/GitHubActions-StaticSite-Dev-Role"
              AWS_REGION="us-east-1"
              ;;
            staging)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_STAGING }}:role/GitHubActions-StaticSite-Staging-Role"
              AWS_REGION="us-east-1"
              ;;
            prod)
              TARGET_ROLE="arn:aws:iam::${{ vars.AWS_ACCOUNT_ID_PROD }}:role/GitHubActions-StaticSite-Prod-Role"
              AWS_REGION="us-east-1"
              ;;
            *)
              echo "‚ùå Invalid environment: $TARGET_ENV"
              exit 1
              ;;
          esac

          echo "target_role_arn=$TARGET_ROLE" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT

          echo "üîê **Environment Authentication Setup**" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $TARGET_ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Role**: $TARGET_ROLE" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region**: $AWS_REGION" >> $GITHUB_STEP_SUMMARY

  deploy_infrastructure:
    name: "üèóÔ∏è Infrastructure Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    needs: [info, setup]
    if: always() && needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_infrastructure == 'true'
    outputs:
      deployment_status: ${{ steps.deploy.outputs.deployment_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.info.outputs.commit_sha }}

      - name: Configure AWS Credentials (Central Role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_CENTRAL }}
          role-session-name: github-actions-central-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.aws_region }}
          audience: sts.amazonaws.com

      - name: Assume Environment-Specific Role
        run: |
          TARGET_ROLE="${{ needs.setup.outputs.target_role_arn }}"
          EXTERNAL_ID="github-actions-static-site"
          SESSION_NAME="github-actions-${{ needs.info.outputs.target_environment }}-${{ github.run_id }}"

          echo "üîÑ Assuming environment role: $TARGET_ROLE"

          CREDS=$(aws sts assume-role \
            --role-arn "$TARGET_ROLE" \
            --role-session-name "$SESSION_NAME" \
            --external-id "$EXTERNAL_ID" \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)

          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to assume role: $TARGET_ROLE"
            exit 1
          fi

          AWS_ACCESS_KEY_ID=$(echo $CREDS | cut -d' ' -f1)
          AWS_SECRET_ACCESS_KEY=$(echo $CREDS | cut -d' ' -f2)
          AWS_SESSION_TOKEN=$(echo $CREDS | cut -d' ' -f3)

          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN" >> $GITHUB_ENV

          echo "‚úÖ Successfully assumed environment role"

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}

      - name: Deploy Infrastructure
        id: deploy
        working-directory: terraform/environments/${{ needs.info.outputs.target_environment }}
        run: |
          echo "üèóÔ∏è **Infrastructure Deployment**" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.info.outputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ needs.info.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY

          # Check for distributed backend configuration
          BACKEND_CONFIG="../backend-configs/${{ needs.info.outputs.target_environment }}.hcl"
          if [ -f "$BACKEND_CONFIG" ]; then
            echo "‚úÖ Using distributed backend configuration: $BACKEND_CONFIG" >> $GITHUB_STEP_SUMMARY
            BACKEND_ARGS="-backend-config=$BACKEND_CONFIG"
          else
            echo "‚ö†Ô∏è Using legacy centralized backend (static backend.tf)" >> $GITHUB_STEP_SUMMARY
            BACKEND_ARGS=""
          fi

          # Initialize Terraform with dynamic backend configuration
          echo "üîß Initializing with backend configuration..."
          timeout 90s tofu init -no-color $BACKEND_ARGS

          # Plan deployment
          echo "üìã Creating deployment plan..."
          timeout 300s tofu plan -no-color -out=deployment.tfplan

          # Apply deployment
          echo "üöÄ Applying infrastructure changes..."
          timeout 180s tofu apply -no-color -auto-approve deployment.tfplan

          # Get outputs (clean output without ANSI codes)
          BUCKET_NAME=$(tofu output -raw s3_bucket_name 2>/dev/null || echo "")
          CLOUDFRONT_ID=$(tofu output -raw cloudfront_distribution_id 2>/dev/null || echo "")
          WEBSITE_URL=$(tofu output -raw website_url 2>/dev/null || echo "")

          echo "deployment_status=success" >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_ENV
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_ENV
          echo "website_url=$WEBSITE_URL" >> $GITHUB_ENV

          echo "‚úÖ Infrastructure deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          if [ -n "$WEBSITE_URL" ]; then
            echo "üåê **Website URL**: $WEBSITE_URL" >> $GITHUB_STEP_SUMMARY
          fi

  deploy_website:
    name: "üåê Website Deployment"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, setup, deploy_infrastructure]
    if: always() && needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_website == 'true' && (needs.deploy_infrastructure.result == 'success' || needs.deploy_infrastructure.result == 'skipped')
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
      cloudfront_url: ${{ steps.deploy.outputs.cloudfront_url }}
      s3_endpoint: ${{ steps.deploy.outputs.s3_endpoint }}
      dashboard_url: ${{ steps.deploy.outputs.dashboard_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.info.outputs.commit_sha }}

      - name: Configure AWS Credentials (Central Role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_CENTRAL }}
          role-session-name: github-actions-central-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.aws_region }}
          audience: sts.amazonaws.com

      - name: Assume Environment-Specific Role
        run: |
          TARGET_ROLE="${{ needs.setup.outputs.target_role_arn }}"
          EXTERNAL_ID="github-actions-static-site"
          SESSION_NAME="github-actions-${{ needs.info.outputs.target_environment }}-${{ github.run_id }}"

          CREDS=$(aws sts assume-role \
            --role-arn "$TARGET_ROLE" \
            --role-session-name "$SESSION_NAME" \
            --external-id "$EXTERNAL_ID" \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)

          AWS_ACCESS_KEY_ID=$(echo $CREDS | cut -d' ' -f1)
          AWS_SECRET_ACCESS_KEY=$(echo $CREDS | cut -d' ' -f2)
          AWS_SESSION_TOKEN=$(echo $CREDS | cut -d' ' -f3)

          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN" >> $GITHUB_ENV

      - name: Deploy Website Content
        id: deploy
        run: |
          echo "üåê **Website Deployment**" >> $GITHUB_STEP_SUMMARY

          # Get infrastructure outputs using dynamic backend configuration
          cd terraform/environments/${{ needs.info.outputs.target_environment }}

          # Check for distributed backend configuration
          BACKEND_CONFIG="../backend-configs/${{ needs.info.outputs.target_environment }}.hcl"
          if [ -f "$BACKEND_CONFIG" ]; then
            BACKEND_ARGS="-backend-config=$BACKEND_CONFIG"
          else
            BACKEND_ARGS=""
          fi

          # Initialize to read outputs
          timeout 60s tofu init $BACKEND_ARGS

          BUCKET_NAME=$(timeout 30s tofu output -raw s3_bucket_name)
          CLOUDFRONT_ID=$(timeout 30s tofu output -raw cloudfront_distribution_id || echo "")
          WEBSITE_URL=$(timeout 30s tofu output -raw website_url)
          CLOUDFRONT_URL=$(timeout 30s tofu output -raw cloudfront_url || echo "")
          S3_ENDPOINT=$(timeout 30s tofu output -raw s3_bucket_domain_name || echo "")
          DASHBOARD_URL=$(timeout 30s tofu output -raw cloudwatch_dashboard_url || echo "")

          echo "- **S3 Bucket**: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFront ID**: $CLOUDFRONT_ID" >> $GITHUB_STEP_SUMMARY

          # Sync website content
          echo "üì§ Syncing website content to S3..."
          timeout 120s aws s3 sync src/ s3://$BUCKET_NAME --delete

          # Invalidate CloudFront cache if distribution exists
          if [ -n "$CLOUDFRONT_ID" ]; then
            echo "üîÑ Invalidating CloudFront cache..."
            timeout 60s aws cloudfront create-invalidation \
              --distribution-id $CLOUDFRONT_ID \
              --paths "/*"
          fi

          echo "deployment_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          echo "cloudfront_url=$CLOUDFRONT_URL" >> $GITHUB_OUTPUT
          echo "s3_endpoint=$S3_ENDPOINT" >> $GITHUB_OUTPUT
          echo "dashboard_url=$DASHBOARD_URL" >> $GITHUB_OUTPUT

          echo "‚úÖ Website deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üåê **Deployment URLs**" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Type | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Primary Site | [$WEBSITE_URL]($WEBSITE_URL) | ‚úÖ Active |" >> $GITHUB_STEP_SUMMARY

          if [ -n "$CLOUDFRONT_URL" ]; then
            echo "| CloudFront CDN | [$CLOUDFRONT_URL]($CLOUDFRONT_URL) | ‚úÖ Active |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| CloudFront CDN | Disabled (cost optimization) | üí∞ Saved |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$S3_ENDPOINT" ]; then
            echo "| S3 Direct | [$S3_ENDPOINT]($S3_ENDPOINT) | ‚úÖ Available |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$DASHBOARD_URL" ]; then
            echo "| Monitoring | [$DASHBOARD_URL]($DASHBOARD_URL) | üìä Active |" >> $GITHUB_STEP_SUMMARY
          fi

  validation:
    name: "‚úÖ Post-Deployment Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, deploy_infrastructure, deploy_website]
    if: always() && (needs.deploy_infrastructure.result == 'success' || needs.deploy_website.result == 'success')
    steps:
      - name: Health Check
        run: |
          echo "‚úÖ **Post-Deployment Validation**" >> $GITHUB_STEP_SUMMARY

          WEBSITE_URL="${{ needs.deploy_website.outputs.deployment_url }}"
          CLOUDFRONT_URL="${{ needs.deploy_website.outputs.cloudfront_url }}"
          S3_ENDPOINT="${{ needs.deploy_website.outputs.s3_endpoint }}"
          DASHBOARD_URL="${{ needs.deploy_website.outputs.dashboard_url }}"

          if [ -n "$WEBSITE_URL" ]; then
            echo "üîç Testing website accessibility..."

            # Test website accessibility
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEBSITE_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Website is accessible (HTTP $HTTP_STATUS)" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ö†Ô∏è Website returned HTTP $HTTP_STATUS" >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê **Validated URLs**" >> $GITHUB_STEP_SUMMARY
            echo "| Resource | URL | HTTP Status |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-----|-------------|" >> $GITHUB_STEP_SUMMARY
            echo "| Primary Site | [$WEBSITE_URL]($WEBSITE_URL) | $HTTP_STATUS |" >> $GITHUB_STEP_SUMMARY

            if [ -n "$CLOUDFRONT_URL" ]; then
              echo "| CloudFront CDN | [$CLOUDFRONT_URL]($CLOUDFRONT_URL) | Active |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| CloudFront CDN | Disabled (cost optimization) | N/A |" >> $GITHUB_STEP_SUMMARY
            fi

            if [ -n "$DASHBOARD_URL" ]; then
              echo "| Monitoring | [$DASHBOARD_URL]($DASHBOARD_URL) | Available |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ÑπÔ∏è No website URL available for validation" >> $GITHUB_STEP_SUMMARY
          fi

          echo "‚úÖ Post-deployment validation completed" >> $GITHUB_STEP_SUMMARY

  summary:
    name: "üìä Deployment Summary"
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [info, deploy_infrastructure, deploy_website, validation, update_readme]
    if: always()
    steps:
      - name: Final Summary
        run: |
          echo "## üìä Final Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.info.outputs.target_environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy_infrastructure.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Website | ${{ needs.deploy_website.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validation.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY

          DEPLOY_URL="${{ needs.deploy_website.outputs.deployment_url }}"
          CLOUDFRONT_URL="${{ needs.deploy_website.outputs.cloudfront_url }}"
          S3_ENDPOINT="${{ needs.deploy_website.outputs.s3_endpoint }}"
          DASHBOARD_URL="${{ needs.deploy_website.outputs.dashboard_url }}"

          if [ -n "$DEPLOY_URL" ]; then
            echo "| Primary URL | [$DEPLOY_URL]($DEPLOY_URL) |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$CLOUDFRONT_URL" ]; then
            echo "| CloudFront URL | [$CLOUDFRONT_URL]($CLOUDFRONT_URL) |" >> $GITHUB_STEP_SUMMARY
            echo "| Architecture | CloudFront + S3 (full stack) |" >> $GITHUB_STEP_SUMMARY
            echo "| Cost Profile | ~\$20-35/month |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| CloudFront URL | Disabled (cost optimization) |" >> $GITHUB_STEP_SUMMARY
            echo "| Architecture | S3-only (cost optimized) |" >> $GITHUB_STEP_SUMMARY
            echo "| Cost Profile | ~\$1-5/month |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$DASHBOARD_URL" ]; then
            echo "| Monitoring | [$DASHBOARD_URL]($DASHBOARD_URL) |" >> $GITHUB_STEP_SUMMARY
          fi

          # Final status determination
          INFRA_SUCCESS="${{ needs.deploy_infrastructure.result }}"
          WEBSITE_SUCCESS="${{ needs.deploy_website.result }}"

          if [[ "$INFRA_SUCCESS" == "success" || "$INFRA_SUCCESS" == "skipped" ]] && \
             [[ "$WEBSITE_SUCCESS" == "success" || "$WEBSITE_SUCCESS" == "skipped" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            if [ -n "$DEPLOY_URL" ]; then
              echo "üåê **Visit**: $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
              if [ -n "$CLOUDFRONT_URL" ]; then
                echo "‚ö° **CDN**: $CLOUDFRONT_URL (Global distribution)" >> $GITHUB_STEP_SUMMARY
              else
                echo "üí∞ **Cost Optimized**: S3-only deployment (~\$1-5/month savings)" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå **DEPLOYMENT FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "Check the deployment job logs for details" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  update_readme:
    name: "üìù Update README Deployment Status"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, deploy_website, validation]
    if: needs.deploy_website.result == 'success' && needs.deploy_website.outputs.deployment_url != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update README with Deployment URLs
        run: |
          echo "üìù **Updating README with deployment information**" >> $GITHUB_STEP_SUMMARY

          TARGET_ENV="${{ needs.info.outputs.target_environment }}"
          DEPLOY_URL="${{ needs.deploy_website.outputs.deployment_url }}"
          CLOUDFRONT_URL="${{ needs.deploy_website.outputs.cloudfront_url }}"
          DASHBOARD_URL="${{ needs.deploy_website.outputs.dashboard_url }}"
          TIMESTAMP=$(date -u "+%Y-%m-%d %H:%M:%S UTC")

          # Determine architecture and cost profile
          if [ -n "$CLOUDFRONT_URL" ]; then
            ARCHITECTURE="CloudFront + S3 (full stack)"
            COST_PROFILE="~\$20-35/month"
          else
            ARCHITECTURE="S3-only (cost optimized)"
            COST_PROFILE="~\$1-5/month"
          fi

          # Determine account ID based on environment
          case "$TARGET_ENV" in
            dev)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_DEV }}"
              ;;
            staging)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_STAGING }}"
              ;;
            prod)
              ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID_PROD }}"
              ;;
            *)
              ACCOUNT_ID="unknown"
              ;;
          esac

          # Create temporary file with updated environment section
          ENV_NAME="$(echo "$TARGET_ENV" | sed 's/./\U&/') Environment"
          {
            echo "**ENV_PLACEHOLDER** ‚úÖ OPERATIONAL"
            echo "- URL: URL_PLACEHOLDER"
            echo "- Architecture: ARCHITECTURE_PLACEHOLDER"
            echo "- Cost Profile: COST_PLACEHOLDER"
            echo "- Last Updated: TIMESTAMP_PLACEHOLDER"
            echo "- Account: ACCOUNT_PLACEHOLDER"
            echo "MONITORING_PLACEHOLDER"
            echo ""
          } > /tmp/env_section.txt

          # Use sed to substitute variables in the template
          sed -i "s/ENV_PLACEHOLDER/$ENV_NAME/g" /tmp/env_section.txt
          sed -i "s|URL_PLACEHOLDER|$DEPLOY_URL|g" /tmp/env_section.txt
          sed -i "s/ARCHITECTURE_PLACEHOLDER/$ARCHITECTURE/g" /tmp/env_section.txt
          sed -i "s/COST_PLACEHOLDER/$COST_PROFILE/g" /tmp/env_section.txt
          sed -i "s/TIMESTAMP_PLACEHOLDER/$TIMESTAMP/g" /tmp/env_section.txt
          sed -i "s/ACCOUNT_PLACEHOLDER/$ACCOUNT_ID/g" /tmp/env_section.txt

          # Add monitoring line if dashboard URL exists
          if [ -n "$DASHBOARD_URL" ]; then
            sed -i "s/MONITORING_PLACEHOLDER/\\n- Monitoring: $DASHBOARD_URL/g" /tmp/env_section.txt
          else
            sed -i "s/MONITORING_PLACEHOLDER//g" /tmp/env_section.txt
          fi

          # Update README by replacing the environment section
          SECTION_PATTERN="**$(echo "$TARGET_ENV" | sed 's/./\U&/') Environment**"

          # Find the line numbers for the section
          START_LINE=$(grep -n "$SECTION_PATTERN" README.md | cut -d: -f1)

          if [ -n "$START_LINE" ]; then
            # Find the end of the section (next ** heading or end of file)
            END_LINE=$(tail -n +$((START_LINE + 1)) README.md | grep -n "^##\|^\*\*" | head -1 | cut -d: -f1)

            if [ -n "$END_LINE" ]; then
              END_LINE=$((START_LINE + END_LINE - 1))
            else
              END_LINE=$(wc -l < README.md)
            fi

            # Replace the section
            head -n $((START_LINE - 1)) README.md > /tmp/readme_new.md
            cat /tmp/env_section.txt >> /tmp/readme_new.md
            tail -n +$((END_LINE + 1)) README.md >> /tmp/readme_new.md
            mv /tmp/readme_new.md README.md
          fi

          echo "‚úÖ README updated for $TARGET_ENV environment" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: $ARCHITECTURE" >> $GITHUB_STEP_SUMMARY
          echo "- **Cost Profile**: $COST_PROFILE" >> $GITHUB_STEP_SUMMARY

      - name: Commit README Updates
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if git diff --quiet README.md; then
            echo "‚ÑπÔ∏è No changes to README.md" >> $GITHUB_STEP_SUMMARY
          else
            git add README.md
            git commit -m "üåê Update ${{ needs.info.outputs.target_environment }} deployment URLs ü§ñ Generated with Claude Code"
            git push
            echo "‚úÖ README.md updated and committed" >> $GITHUB_STEP_SUMMARY
          fi
