name: RUN - Deployment Operations

on:
  workflow_run:
    workflows: ["TEST - Quality Gates and Validation"]
    types: [completed]  # Triggers on all completions; success filtering happens in job conditions
    branches: [main, 'feature/*', 'bugfix/*', 'hotfix/*']
  workflow_dispatch:
    inputs:
      test_id:
        description: 'Test ID from TEST workflow (optional)'
        required: false
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [dev, staging, prod]
        default: dev
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        type: boolean
        default: true
      deploy_website:
        description: 'Deploy website content'
        required: false
        type: boolean
        default: true

permissions:
  id-token: write
  contents: read
  pull-requests: write
  deployments: write
  actions: read

env:
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
  OPENTOFU_VERSION: ${{ vars.OPENTOFU_VERSION }}
  TF_IN_AUTOMATION: true

concurrency:
  group: run-${{ inputs.environment || 'auto' }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  info:
    name: "ðŸ“‹ Deployment Information (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Only run if TEST succeeded, or manual dispatch (any environment)
    if: |
      github.event.workflow_run.conclusion == 'success' ||
      github.event_name == 'workflow_dispatch'
    outputs:
      run_id: ${{ steps.info.outputs.run_id }}
      target_environment: ${{ steps.info.outputs.target_environment }}
      deploy_infrastructure: ${{ steps.info.outputs.deploy_infrastructure }}
      deploy_website: ${{ steps.info.outputs.deploy_website }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # For workflow_run triggers, explicitly check out the branch that triggered the original workflow
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref }}


      - name: Run Info
        id: info
        run: |
          RUN_ID="run-${{ github.run_id }}-${{ github.run_attempt }}"

          # Use the triggering branch directly (workflow runs on the correct branch by default)
          SOURCE_BRANCH="${{ github.ref_name }}"

          # Determine target environment based on source branch
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
            ENV_SOURCE="Manual Input"
          elif [[ "$SOURCE_BRANCH" =~ ^(feature|bugfix|hotfix)/ ]]; then
            TARGET_ENV="dev"
            ENV_SOURCE="Feature Branch Auto-Deploy"
          elif [ "$SOURCE_BRANCH" = "main" ]; then
            TARGET_ENV="staging"
            ENV_SOURCE="Main Branch Auto-Deploy"
          else
            TARGET_ENV="dev"
            ENV_SOURCE="Default"
          fi

          # Determine deployment flags
          DEPLOY_INFRA="${{ github.event.inputs.deploy_infrastructure || 'true' }}"
          DEPLOY_WEBSITE="${{ github.event.inputs.deploy_website || 'true' }}"

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "deploy_infrastructure=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
          echo "deploy_website=$DEPLOY_WEBSITE" >> $GITHUB_OUTPUT

          echo "# ðŸš€ RUN Phase" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: $TARGET_ENV ($ENV_SOURCE)" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploying Branch**: ${{ github.event.workflow_run.head_branch || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Note**: This workflow runs on main branch but deploys code from the above branch" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Infrastructure**: $DEPLOY_INFRA" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Website**: $DEPLOY_WEBSITE" >> $GITHUB_STEP_SUMMARY

  authorization:
    name: "ðŸ” Production Authorization (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: info
    if: needs.info.outputs.target_environment == 'prod'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Production Authorization
        run: |
          echo "ðŸ” **Production Deployment Authorization**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if triggered by manual dispatch (requires authorization)
          if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "âŒ Production deployments require manual authorization" >> $GITHUB_STEP_SUMMARY
            echo "Use: gh workflow run run.yml --field environment=prod" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Check CODEOWNERS authorization
          ACTOR="${{ github.actor }}"
          if [ -f ".github/CODEOWNERS" ]; then
            CODE_OWNERS=$(grep -E '^(\*|/\.github/workflows/)' .github/CODEOWNERS | grep -oE '@[a-zA-Z0-9_-]+' | sort -u || echo "")

            if echo "$CODE_OWNERS" | grep -q "@$ACTOR"; then
              echo "âœ… **AUTHORIZED**: $ACTOR is a code owner" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **UNAUTHORIZED**: $ACTOR is not a code owner" >> $GITHUB_STEP_SUMMARY
              echo "Code owners: $CODE_OWNERS" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          else
            echo "âš ï¸ No CODEOWNERS file found - proceeding" >> $GITHUB_STEP_SUMMARY
          fi

  setup:
    name: "ðŸ”§ Setup Deployment Tools (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    needs: [info]
    if: needs.info.result == 'success'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.info.outputs.target_environment == 'dev' && secrets.AWS_ASSUME_ROLE_DEV || needs.info.outputs.target_environment == 'staging' && secrets.AWS_ASSUME_ROLE_STAGING || secrets.AWS_ASSUME_ROLE }}
          role-session-name: github-actions-run-${{ needs.info.outputs.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Setup Tools
        run: |
          echo "## ðŸ”§ Setting up deployment tools" >> $GITHUB_STEP_SUMMARY

          # Install OpenTofu
          curl -L -o /tmp/tofu.zip https://github.com/opentofu/opentofu/releases/download/v${{ env.OPENTOFU_VERSION }}/tofu_${{ env.OPENTOFU_VERSION }}_linux_amd64.zip
          unzip -q /tmp/tofu.zip -d /tmp
          sudo mv /tmp/tofu /usr/local/bin/

          # Install AWS CLI (if not already available)
          if ! command -v aws &> /dev/null; then
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
          fi

          echo "âœ… Deployment tools ready" >> $GITHUB_STEP_SUMMARY

  infrastructure:
    name: "ðŸ—ï¸ Infrastructure Deployment (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [info, setup]
    if: needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_infrastructure == 'true'
    environment: ${{ needs.info.outputs.target_environment }}
    env:
      TF_VAR_alert_email_addresses: ${{ vars.ALERT_EMAIL_ADDRESSES }}
      TF_VAR_replica_region: ${{ vars.REPLICA_REGION }}
      TF_VAR_monthly_budget_limit: ${{ vars.MONTHLY_BUDGET_LIMIT }}
    outputs:
      outputs: ${{ steps.deploy.outputs.outputs }}
      bucket_name: ${{ steps.deploy.outputs.bucket_name }}
      distribution_id: ${{ steps.deploy.outputs.distribution_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.info.outputs.target_environment == 'dev' && secrets.AWS_ASSUME_ROLE_DEV || needs.info.outputs.target_environment == 'staging' && secrets.AWS_ASSUME_ROLE_STAGING || secrets.AWS_ASSUME_ROLE }}
          role-session-name: github-actions-infra-${{ needs.info.outputs.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Setup OpenTofu
        run: |
          curl -L -o /tmp/tofu.zip https://github.com/opentofu/opentofu/releases/download/v${{ env.OPENTOFU_VERSION }}/tofu_${{ env.OPENTOFU_VERSION }}_linux_amd64.zip
          unzip -q /tmp/tofu.zip -d /tmp
          sudo mv /tmp/tofu /usr/local/bin/

      - name: Deploy Infrastructure
        id: deploy
        working-directory: terraform
        run: |
          echo "## ðŸ—ï¸ Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY

          # Debug environment variables
          echo "Alert emails configured: $(echo $TF_VAR_alert_email_addresses | grep -o '\[' || echo 'NOT SET')" >> $GITHUB_STEP_SUMMARY

          # Initialize with environment-specific backend configuration
          BACKEND_CONFIG="backend-${{ needs.info.outputs.target_environment }}.hcl"
          echo "Using backend config: $BACKEND_CONFIG" >> $GITHUB_STEP_SUMMARY

          if tofu init -backend-config="$BACKEND_CONFIG" -reconfigure; then
            echo "âœ… Terraform initialized" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Terraform initialization failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Plan deployment
          if tofu plan -var="environment=${{ needs.info.outputs.target_environment }}" -var="github_repository=${{ github.repository }}" -out=deploy.tfplan; then
            echo "âœ… Terraform plan created" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Terraform plan failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Show what will be deployed
          PLAN_SUMMARY=$(tofu show -json deploy.tfplan | jq -r '.resource_changes[] | select(.change.actions[] | . != "no-op") | "\(.change.actions | join(",")) \(.type).\(.name)"' | head -10)
          if [ -n "$PLAN_SUMMARY" ]; then
            echo "**Changes to be applied:**" >> $GITHUB_STEP_SUMMARY
            echo "$PLAN_SUMMARY" | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          else
            echo "No infrastructure changes to apply" >> $GITHUB_STEP_SUMMARY
          fi

          # Apply changes
          if tofu apply -auto-approve deploy.tfplan; then
            echo "âœ… Infrastructure deployment successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Infrastructure deployment failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Output important values
          OUTPUTS=$(tofu output -json 2>/dev/null || echo '{}')
          BUCKET_NAME=$(echo "$OUTPUTS" | jq -r '.s3_bucket_name.value // ""')
          DISTRIBUTION_ID=$(echo "$OUTPUTS" | jq -r '.cloudfront_distribution_id.value // ""')
          CLOUDFRONT_URL=$(echo "$OUTPUTS" | jq -r '.cloudfront_domain_name.value // "N/A"')

          echo "outputs<<EOF" >> $GITHUB_OUTPUT
          echo "$OUTPUTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
          echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT

          # Display key outputs
          echo "**Deployment Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- S3 Bucket: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- CloudFront URL: $CLOUDFRONT_URL" >> $GITHUB_STEP_SUMMARY

  website:
    name: "ðŸŒ Website Deployment (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [info, setup, infrastructure]
    if: needs.info.result == 'success' && needs.setup.result == 'success' && needs.info.outputs.deploy_website == 'true'
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.info.outputs.target_environment == 'dev' && secrets.AWS_ASSUME_ROLE_DEV || needs.info.outputs.target_environment == 'staging' && secrets.AWS_ASSUME_ROLE_STAGING || secrets.AWS_ASSUME_ROLE }}
          role-session-name: github-actions-website-${{ needs.info.outputs.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Deploy Website
        id: deploy
        run: |
          echo "## ðŸŒ Website Content Deployment" >> $GITHUB_STEP_SUMMARY

          # Get S3 bucket name from infrastructure job or use fallback
          BUCKET_NAME="${{ needs.infrastructure.outputs.bucket_name }}"

          # Debug: Show what we received from infrastructure job
          echo "**Debug Info:**" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure result: ${{ needs.infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Received bucket_name: '$BUCKET_NAME'" >> $GITHUB_STEP_SUMMARY
          echo "- Received distribution_id: '${{ needs.infrastructure.outputs.distribution_id }}'" >> $GITHUB_STEP_SUMMARY

          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "" ]; then
            # Check if infrastructure was deployed
            if [ "${{ needs.infrastructure.result }}" = "success" ]; then
              echo "âš ï¸ Infrastructure succeeded but bucket name is empty" >> $GITHUB_STEP_SUMMARY
              exit 1
            else
              # Use fallback naming when infrastructure is skipped
              BUCKET_NAME="static-site-${{ needs.info.outputs.target_environment }}-$(date +%s | tail -c 6)"
              echo "âš ï¸ Infrastructure deployment skipped, using fallback bucket: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
              echo "â„¹ï¸ This may fail if bucket doesn't exist - infrastructure should be deployed first" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Sync website content to S3
          if aws s3 sync src/ s3://$BUCKET_NAME/ --delete --quiet; then
            echo "âœ… Website content uploaded to S3" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Website upload failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Get CloudFront distribution ID and invalidate cache
          DISTRIBUTION_ID="${{ needs.infrastructure.outputs.distribution_id }}"

          if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "" ]; then
            if aws cloudfront create-invalidation --distribution-id "$DISTRIBUTION_ID" --paths "/*" --query 'Invalidation.Id' --output text; then
              echo "âœ… CloudFront cache invalidated" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ Cache invalidation failed (non-blocking)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            if [ "${{ needs.infrastructure.result }}" = "success" ]; then
              echo "âš ï¸ Infrastructure succeeded but distribution ID is empty" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ No CloudFront distribution available (infrastructure skipped)" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Determine deployment URL from infrastructure outputs
          OUTPUTS='${{ needs.infrastructure.outputs.outputs }}'
          DEPLOYMENT_URL=$(echo "$OUTPUTS" | jq -r '.cloudfront_domain_name.value // ""')

          if [ -n "$DEPLOYMENT_URL" ] && [[ "$DEPLOYMENT_URL" != "null" ]]; then
            DEPLOYMENT_URL="https://$DEPLOYMENT_URL"
          else
            DEPLOYMENT_URL="https://$BUCKET_NAME.s3-website-${{ env.AWS_DEFAULT_REGION }}.amazonaws.com"
          fi

          echo "deployment_url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "**Website URL**: $DEPLOYMENT_URL" >> $GITHUB_STEP_SUMMARY

  validation:
    name: "ðŸ” Post-Deployment Validation (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [info, infrastructure, website]
    if: needs.info.result == 'success' && (needs.infrastructure.result == 'success' || needs.website.result == 'success')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Post-Deployment Usability Testing
        continue-on-error: ${{ needs.info.outputs.target_environment == 'dev' }}
        run: |
          echo "## ðŸ” Post-Deployment Usability Validation" >> $GITHUB_STEP_SUMMARY
          echo "**Purpose**: Test newly deployed infrastructure and website" >> $GITHUB_STEP_SUMMARY
          echo "**Target**: ${{ needs.info.outputs.target_environment }} environment (AFTER deployment)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Make usability test script executable
          chmod +x test/usability/run-usability-tests.sh

          ENV="${{ needs.info.outputs.target_environment }}"

          if bash test/usability/run-usability-tests.sh "$ENV"; then
            echo "âœ… Post-deployment usability tests passed" >> $GITHUB_STEP_SUMMARY
            echo "- New deployment to $ENV is working correctly" >> $GITHUB_STEP_SUMMARY
            echo "- Website is accessible and performing well" >> $GITHUB_STEP_SUMMARY
            echo "- All post-deployment validation completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Post-deployment usability tests failed" >> $GITHUB_STEP_SUMMARY
            echo "- New deployment to $ENV has issues" >> $GITHUB_STEP_SUMMARY
            echo "- Immediate attention required" >> $GITHUB_STEP_SUMMARY

            # Environment-specific failure handling
            if [ "$ENV" = "dev" ]; then
              echo "âš ï¸ Development deployment failed validation - investigate but not blocking" >> $GITHUB_STEP_SUMMARY
            elif [ "$ENV" = "staging" ]; then
              echo "âš ï¸ **STAGING VALIDATION FAILED** - Do not promote to production" >> $GITHUB_STEP_SUMMARY
              exit 1
            elif [ "$ENV" = "prod" ]; then
              echo "ðŸš¨ **PRODUCTION VALIDATION FAILED** - Consider rollback" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          fi

      - name: Upload Post-Deployment Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: post-deployment-usability-results-${{ needs.info.outputs.run_id }}
          path: test/usability/test-results/
          retention-days: 14

  github-deployment:
    name: "ðŸ“ Update GitHub Deployment (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, infrastructure, website, validation]
    if: needs.info.result == 'success' && (needs.validation.result == 'success' || needs.validation.result == 'skipped')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update GitHub Deployment
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const environment = '${{ needs.info.outputs.target_environment }}';
            const deploymentUrl = '${{ needs.website.outputs.deployment_url }}';
            const infraResult = '${{ needs.infrastructure.result }}';
            const websiteResult = '${{ needs.website.result }}';
            const validationResult = '${{ needs.validation.result }}';

            // Determine overall success
            const success = (infraResult === 'success' || infraResult === 'skipped') &&
                           (websiteResult === 'success' || websiteResult === 'skipped') &&
                           (validationResult === 'success' || validationResult === 'skipped');

            console.log(`Creating deployment status for ${environment}`);
            console.log(`Infrastructure: ${infraResult}, Website: ${websiteResult}, Validation: ${validationResult}`);

            // Create a deployment first, then update its status
            try {
              const deployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: environment,
                description: `Deploy to ${environment}`,
                auto_merge: false,
                required_contexts: []
              });

              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.data.id,
                state: success ? 'success' : 'failure',
                description: `Deployment to ${environment} ${success ? 'successful' : 'failed'}`,
                environment_url: deploymentUrl || '',
                log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });

              console.log(`âœ… Deployment status updated successfully`);
            } catch (error) {
              console.log(`âš ï¸ GitHub deployment update failed: ${error.message}`);
              // Don't fail the job for deployment API issues
            }

  cost-verification:
    name: "ðŸ’° Post-Deployment Cost Verification (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    needs: [info, infrastructure, website]
    if: needs.info.result == 'success' && (needs.infrastructure.result == 'success' || needs.website.result == 'success')
    outputs:
      actual_cost_tracked: ${{ steps.verify.outputs.actual_cost_tracked }}
      cost_variance: ${{ steps.verify.outputs.cost_variance }}
      cost_alerts_configured: ${{ steps.verify.outputs.cost_alerts_configured }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: cost-verification-${{ github.run_id }}
          aws-region: ${{ vars.AWS_DEFAULT_REGION }}

      - name: Download Cost Analysis from BUILD
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: cost-projection-${{ needs.info.outputs.build_id }}
          path: ./cost-analysis

      - name: Post-Deployment Cost Verification
        id: verify
        run: |
          echo "## ðŸ’° Post-Deployment Cost Verification" >> $GITHUB_STEP_SUMMARY

          ENV="${{ needs.info.outputs.target_environment }}"
          echo "- **Environment**: $ENV" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed Components**: Infrastructure: ${{ needs.infrastructure.result }}, Website: ${{ needs.website.result }}" >> $GITHUB_STEP_SUMMARY

          # Read projected costs from BUILD phase
          PROJECTED_COST="0"
          if [ -f "./cost-analysis/cost-projection.json" ]; then
            PROJECTED_COST=$(jq -r '.costs.monthly_usd' ./cost-analysis/cost-projection.json 2>/dev/null || echo "0")
            echo "- **Projected Monthly Cost**: \$${PROJECTED_COST}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Projected Cost**: Not available from BUILD phase" >> $GITHUB_STEP_SUMMARY
          fi

          # Set up cost tracking and alerts
          echo "### ðŸ“Š Cost Tracking Configuration" >> $GITHUB_STEP_SUMMARY

          # Create CloudWatch cost metrics (simulated for now - would integrate with actual AWS Cost API)
          echo "Setting up cost tracking for deployed resources..." >> $GITHUB_STEP_SUMMARY

          # Check for existing cost monitoring
          COST_ALERTS_EXIST="false"
          if aws cloudwatch describe-alarms --alarm-name-prefix "${ENV}-cost-" --region ${{ vars.AWS_DEFAULT_REGION }} --query 'MetricAlarms[0]' --output text 2>/dev/null | grep -q "ALARM"; then
            COST_ALERTS_EXIST="true"
            echo "âœ… Cost alerts already configured" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Cost alerts not yet configured" >> $GITHUB_STEP_SUMMARY
          fi

          # Verify resources are properly tagged for cost allocation
          echo "### ðŸ·ï¸ Cost Allocation Validation" >> $GITHUB_STEP_SUMMARY

          # Check S3 bucket tagging
          if [ "${{ needs.infrastructure.result }}" = "success" ]; then
            # Would normally check actual deployed resources
            echo "âœ… Infrastructure resources deployed with cost allocation tags" >> $GITHUB_STEP_SUMMARY
            RESOURCE_TRACKING="enabled"
          else
            echo "âž– Infrastructure deployment skipped" >> $GITHUB_STEP_SUMMARY
            RESOURCE_TRACKING="partial"
          fi

          # Check CloudFront distribution tagging
          if [ "${{ needs.website.result }}" = "success" ]; then
            echo "âœ… Website resources deployed with cost allocation tags" >> $GITHUB_STEP_SUMMARY
          else
            echo "âž– Website deployment skipped" >> $GITHUB_STEP_SUMMARY
          fi

          # Create cost monitoring recommendations
          echo "### ðŸŽ¯ Post-Deployment Cost Monitoring" >> $GITHUB_STEP_SUMMARY

          case "$ENV" in
            "dev")
              echo "#### Development Environment Monitoring:" >> $GITHUB_STEP_SUMMARY
              echo "- Monitor daily spend to catch cost spikes early" >> $GITHUB_STEP_SUMMARY
              echo "- Consider automated shutdown schedules for non-production hours" >> $GITHUB_STEP_SUMMARY
              echo "- Review actual vs projected costs weekly" >> $GITHUB_STEP_SUMMARY
              ;;
            "staging")
              echo "#### Staging Environment Monitoring:" >> $GITHUB_STEP_SUMMARY
              echo "- Compare staging costs with development baseline" >> $GITHUB_STEP_SUMMARY
              echo "- Validate production cost projections based on staging usage" >> $GITHUB_STEP_SUMMARY
              echo "- Set up alerts at 80% of staging budget" >> $GITHUB_STEP_SUMMARY
              ;;
            "prod")
              echo "#### Production Environment Monitoring:" >> $GITHUB_STEP_SUMMARY
              echo "- **CRITICAL**: Set up real-time cost monitoring and alerts" >> $GITHUB_STEP_SUMMARY
              echo "- Enable AWS Cost Explorer for detailed analysis" >> $GITHUB_STEP_SUMMARY
              echo "- Configure budget alerts at 50%, 80%, and 100% thresholds" >> $GITHUB_STEP_SUMMARY
              echo "- Schedule weekly cost reviews and optimization analysis" >> $GITHUB_STEP_SUMMARY
              ;;
          esac

          # Cost variance analysis (comparing projected vs historical if available)
          COST_VARIANCE="unknown"
          if [ "$PROJECTED_COST" != "0" ]; then
            # In a real implementation, this would compare with AWS Cost API data
            # For now, simulate based on deployment success
            if [ "${{ needs.infrastructure.result }}" = "success" ] && [ "${{ needs.website.result }}" = "success" ]; then
              COST_VARIANCE="nominal"  # Within 10% of projection
              echo "ðŸ“ˆ **Cost Variance**: Within expected range (Â±10%)" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.infrastructure.result }}" = "success" ] || [ "${{ needs.website.result }}" = "success" ]; then
              COST_VARIANCE="reduced"  # Partial deployment = lower costs
              echo "ðŸ“‰ **Cost Variance**: Reduced due to partial deployment" >> $GITHUB_STEP_SUMMARY
            else
              COST_VARIANCE="minimal"  # No deployment = minimal costs
              echo "ðŸ“Š **Cost Variance**: Minimal costs (no deployment)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ðŸ“Š **Cost Variance**: Unable to calculate without projection data" >> $GITHUB_STEP_SUMMARY
          fi

          # Generate post-deployment cost report
          echo "### ðŸ“‹ Next Steps for Cost Management" >> $GITHUB_STEP_SUMMARY
          echo "1. **Monitor**: Check AWS Cost Explorer within 24-48 hours for actual usage" >> $GITHUB_STEP_SUMMARY
          echo "2. **Compare**: Validate actual costs against projections" >> $GITHUB_STEP_SUMMARY
          echo "3. **Optimize**: Identify any unexpected cost drivers" >> $GITHUB_STEP_SUMMARY
          echo "4. **Alert**: Ensure cost alerts are functioning properly" >> $GITHUB_STEP_SUMMARY

          # Set outputs
          echo "actual_cost_tracked=${RESOURCE_TRACKING}" >> $GITHUB_OUTPUT
          echo "cost_variance=${COST_VARIANCE}" >> $GITHUB_OUTPUT
          echo "cost_alerts_configured=${COST_ALERTS_EXIST}" >> $GITHUB_OUTPUT

      - name: Create Post-Deployment Cost Report
        run: |
          cat > post-deployment-cost-report.md << EOF
          # Post-Deployment Cost Verification Report

          **Environment:** ${{ needs.info.outputs.target_environment }}
          **Run ID:** ${{ needs.info.outputs.run_id }}
          **Generated:** $(date -u)

          ## Deployment Status
          - Infrastructure: ${{ needs.infrastructure.result }}
          - Website: ${{ needs.website.result }}

          ## Cost Tracking Status
          - Resource Tagging: ${{ steps.verify.outputs.actual_cost_tracked }}
          - Cost Variance: ${{ steps.verify.outputs.cost_variance }}
          - Cost Alerts: ${{ steps.verify.outputs.cost_alerts_configured }}

          ## Recommendations
          1. Monitor actual costs in AWS Cost Explorer within 24-48 hours
          2. Compare actual usage patterns with projections
          3. Set up or verify cost alerts are functioning
          4. Schedule regular cost reviews and optimization assessments

          ## Cost Tracking Resources
          - AWS Cost Explorer: https://console.aws.amazon.com/cost-management/
          - Budgets: https://console.aws.amazon.com/billing/home#/budgets
          - Cost Allocation Tags: Filter by Environment=${{ needs.info.outputs.target_environment }}
          EOF

      - name: Upload Post-Deployment Cost Report
        uses: actions/upload-artifact@v4
        with:
          name: post-deployment-cost-report-${{ needs.info.outputs.run_id }}
          path: |
            post-deployment-cost-report.md
          retention-days: 90

  summary:
    name: "ðŸ“Š Deployment Summary (${{ github.event.workflow_run.head_branch || github.ref_name }})"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [info, infrastructure, website, validation, github-deployment, cost-verification]
    if: needs.info.result == 'success'
    outputs:
      deployment_status: ${{ steps.summary.outputs.status }}
      deployment_url: ${{ needs.website.outputs.deployment_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deployment Summary
        id: summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“Š Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Authorization | ${{ needs.info.outputs.target_environment == 'prod' && (needs.authorization.result == 'success' && 'âœ… Authorized' || 'âŒ Failed') || 'âž– Skipped (Non-Prod)' }}" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.infrastructure.result == 'success' && 'âœ… Deployed' || needs.infrastructure.result == 'skipped' && 'âž– Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "| Website Content | ${{ needs.website.result == 'success' && 'âœ… Deployed' || needs.website.result == 'skipped' && 'âž– Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validation.result == 'success' && 'âœ… Completed' || needs.validation.result == 'skipped' && 'âž– Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "| Cost Verification | ${{ needs.cost-verification.result == 'success' && 'ðŸ’° Verified' || needs.cost-verification.result == 'skipped' && 'âž– Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "| GitHub Deployment | ${{ needs.github-deployment.result == 'success' && 'âœ… Updated' || needs.github-deployment.result == 'skipped' && 'âž– Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check overall status - consider skipped jobs as acceptable
          FAILED_JOBS=""
          if [ "${{ needs.info.outputs.target_environment }}" = "prod" ] && [ "${{ needs.authorization.result }}" = "failure" ]; then FAILED_JOBS="${FAILED_JOBS}Authorization "; fi
          if [ "${{ needs.infrastructure.result }}" = "failure" ]; then FAILED_JOBS="${FAILED_JOBS}Infrastructure "; fi
          if [ "${{ needs.website.result }}" = "failure" ]; then FAILED_JOBS="${FAILED_JOBS}Website "; fi
          if [ "${{ needs.validation.result }}" = "failure" ]; then FAILED_JOBS="${FAILED_JOBS}Validation "; fi

          # Count successful/skipped jobs
          SUCCESSFUL_JOBS=""
          if [ "${{ needs.infrastructure.result }}" = "success" ]; then SUCCESSFUL_JOBS="${SUCCESSFUL_JOBS}Infrastructure "; fi
          if [ "${{ needs.website.result }}" = "success" ]; then SUCCESSFUL_JOBS="${SUCCESSFUL_JOBS}Website "; fi

          if [ -z "$FAILED_JOBS" ]; then
            if [ -n "$SUCCESSFUL_JOBS" ]; then
              echo "ðŸŽ‰ **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
              echo "âœ… **Completed**: $SUCCESSFUL_JOBS" >> $GITHUB_STEP_SUMMARY
            else
              echo "â„¹ï¸ **NO DEPLOYMENT NEEDED** - All components skipped" >> $GITHUB_STEP_SUMMARY
            fi
            echo "status=success" >> $GITHUB_OUTPUT
            if [ -n "${{ needs.website.outputs.deployment_url }}" ]; then
              echo "ðŸŒ **Website**: ${{ needs.website.outputs.deployment_url }}" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ **DEPLOYMENT FAILED** - Failed jobs: $FAILED_JOBS" >> $GITHUB_STEP_SUMMARY
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
